# 객체
1. 자바스크립트의 기본 데이터 타입은 객체다.
2. 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다.
    - 프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열과 값이 연결된 집합이라고 할 수 있다.
    - 문자열 - 값 형태의 연결 구조는 기초 자료구조에서 해시, 해시 테이블, 사전, 연관배열로 소개하고 있다.
3. 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 **'프로토타입'이라고 하는 다른 객체의 프로퍼티를 상속받는다. 객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 '프로토타입 상속'이라고 한다. 프로토타입 상속은 자바스크립트의 핵심 기능이다.**
4. 자바스크립트에서는 문자열, 숫자, true/false 와 null/undefined를 제외한 나머지는 객체다. 비록 문자열과 숫자, 불리언 값은 객체는 아니지만 값이 정해진 객체로 취급된다.
5. 객체의 각 프로퍼티는 이름과 값 외에 '프로퍼티 속성'이라고 하는 연관된 값을 갖는다.
    - 쓰기(writable) 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.
    - 열거(enumerable) 속성은 프로퍼티의 이름을 for/in 루프에서 읽을 수 있는지 여부를 결정한다.
    - 설정(configurable) 속성은 프로퍼티의 삭제 가능 여부와 프로퍼티 속성의 변경 여부를 결정한다.
6. 객체의 프로퍼티 뿐 아니라, 모든 객체는 세 가지의 속성을 갖는다.
    - 객체의 prototype은 상속받은 프로퍼티들을 가진 객체에 대한 참조변수다.
    - 객체의 class는 객체의 유형을 뷴류하는 문자열이다.
    - ECMAScript 5에서 객체의 extensible 플래그는 객체에 새 프로퍼티의 추가 여부를 결정한다.

### 객체 용어
1. 네이티브 객체
    - ECMAScript 명세에 정의된 객체이거나 객체의 글래스다.  
    Array, Function, Date, 정규 표현식들은 전부 네이티브 객체다.
2. 호스트 객체
    - 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다. HTMLElement 객체는 웹페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체다. 호스트 객체는 호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 함수 객체로 정의 하는 것과 마찬가지로 네이티브 객체일 수도 있다.
3. 사용자 정의 객체
    - 자바스크립트 코드의 실행으로 생성된 객체다.
4. 고유 프로퍼티
    - 객체에 직접 코드로 정의한 프로퍼티이다.
5. 상속받은 프로퍼티
    - 객체 프로토타입 객체에 의해 정의된 프로퍼티를 말한다.

# 객체 생성하기
1. 객체는 객체 리터럴 또는 new 키워드를 이용해 생성될 수 있고, ECMAScript 5의 Object.create() 함수를 통해 생성될 수도 있다.

### 1. 객체 리터럴
1. 객체 리터럴은 리터럴이 평가되는 시점에 새로운 객체가 생성됨과 동시에 초기화되는 표현식이다.
    - ```
        var empty = {}; // 프로퍼티가 없는 빈 객체
        var point = {x: 0, y: 0} // 두 개의 프로퍼티 x,y를 정의한다.
        var point2 = {x: point.x, y: point.y + 1} // 프로퍼티를 수식 값으로 정의한다.
        var book = {
            'main title' : 'Javascript' //프로퍼티 이름은 공백과
            'sub-title' : 'The Definitive Guide' // 하이픈(-)을 포함할 수 있다.
            'for': 'all' //예약어인 for도 인용부호를 둘러싸서 문자열 리터럴로 사용할 수 있다.
            author: { //프로퍼티 author의 값은 객체 그 자체다.
                firstName: 1, //프로퍼티 이름은 인용부호로 감싸지 않을수도 있다.
                surname: 2
            }

        }
        ```
2. ECMAScript 5에서 객체 리터럴의 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시한다.

### 2. new를 사용해 객체 생성하기
1. new 연산자로 객체를 만들고, 초기화할 수 있다.
2. new 키워드는 반드시 함수 호출 다음에 와야한다. 이때 사용되는 함수를 생성자라고 하는데, 새로 생성된 객체를 초기화하는 역할을 한다.

### 3. 프로토타입
1. 자바스크립트의 모든 객체는 두 번째 자바스크립트 객체(극히 드물지만 null일 수도 있다.)와 연관되어 있다. 이 두 번째 객체는 프로토타입으로 알려져 있고, 이때 첫 번째 객체는 프로토타입으로부터 프로퍼티들을 상속 받는다.
2. 객체 리터럴 생성 시 프로토타입 객체
    - Object.prototype
3. new 키워드 객체 생성 시 프로토타입 객체
    - 생성자의 프로토타입을 자신의 프로토타입으로 하는 객체가 생성된다.
4. Object.prototype은 prototype이 없다.
5. 프로토타입 체인
    - 프로토타입 객체들의 연속된 연결을 '프로토타입 체인'이라고 한다.

### 4. Object.create()
1. Object.create 메서드의 첫 번째 인자로 프로토타입 객체를 전달할 수 있고, 두 번째 인자는 새 객체의 프로퍼티 정보를 가진 객체로 전달 할 수 있으나 생략 가능하다.
2. Object.create()는 정적(static) 함수로, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서 단순히 프로토타입 객체를 넘기기만 하면 된다.
    - ```
        var o1 = Object.create({x:1, y:2});
        ```
3. 프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다. 하지만 이 경우에는 새롭게 생성된 객체가 어떠한 객체도 상속받지 않기 때문에 toString() 메서드와 같은 기본적인 메서드조차 사용할 수 없다. 다시 말해, + 연산자 또한 사용할 수 없다.
    - ```
        var o2 = Object.create(null);

        var o3 = Object.create(Object.prototype);
        //o3는 {} 또는 new Object()와 같은 객체다.
        ```

# 프로퍼티 접근 및 설정
1. 프로퍼티 값을 가져오기 위해서는 마침표(.) 연산자 또는 대괄호([]) 연산자를 사용한다.
2. 프로퍼티를 만들거나 설정하기 위해서는 객체의 프로퍼티에 접근하는 것과 동일하게 마침표 연산자 또는 대활호 연산자를 사용한다. 이때 프로퍼티는 할당 표현식의 오른쪽에 위치한다.
    - ```
        book.edition = 6;
        book['main title'] = 'abc';
        ```

### 1. 연관 배열로서의 객체
1. 마침표(.) 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름이 반드시 식별자로 표현되어야한다. 식별자는 데이터 타입이 아니라 자바스크립트 프로그램에 직접 작성한 이름이기 때문에 프로그램이 실행될 때 변경할 수 없다.
2. 반면에 [] 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름이 문자열로 표현된다. 문자열은 자바스크립트의 데이터 타입이기 때문에 프로그램 실행 시점에 생성되고 중간에 변경될 수 있다.
    - ```
        var addr = '';
        for(i = 0; i < 4; i++) {
            addr += customer['address' + i ] + '\n';
        }
        ```

### 2. 상속
1. 자바스크립트 객체는 고유 프로퍼티들을 가지고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티들을 상속받는다.
    - 예를 들어 객체 o.에서 프로퍼티 x를 찾는다고 하자.
    - 객체 o가 프로퍼티 x를 갖고 있지 않으면
    - ***o의 프로토타입 객체에서 x를 찾는다.***
    - 만약 프로로타입 객체에 고유 프로퍼티 x가 없다면
    - ***상위 객체의 프로로타입 객체에서 프로퍼티 x를 찾는다***
    - 이러한 작업은 ***프로퍼티 x를 찾거나 해당 객체 또는 객체의 프로토타입 객체가 null이 될 때까지 계속된다.***
    - 이처럼 객체의 프로토타입 속성은 특정 프로퍼티가 어떤 객체에 속해 있는지 알 수 있는 프로퍼티 체인 또는 연결 리스트를 생성한다.
    - ```
        var o = {}; //o는 Objejct.prototype을 상속받은 객체고,
        o.x = 1; //고유 프로퍼티 x를 갖는다.
        var p = inherit(o); //p는 객체 o와 Object.prototype을 상속받는 객체고,
        p.y = 2; //고유 프로퍼티 y를 갖는다.
        var q = inherit(p); //q는 객체 p와 o, Object.prototype을 상속받는 객체고,
        q.z = 3; // 고유 프로퍼티 z를 갖는다.
        var s = q.toString(); // q는 Object.prototype을 상속받았기 때문에 toString() 을 사용할 수 있었다.
        q.x + q.y; //결과는 3이고, q의 프로퍼티 x와 y는 각각 객체 o와 p에서 상속받았다.
        ```
2. 객체 o의 프로퍼티 x에 값을 설정해보자.
    - 객체 o가 상속받지 않은 고유 프로퍼티 x를 가지고 있는 경우
        - 기존의 프로퍼티 값을 단순히 바꿀 수 있다.
    - 프로퍼티 x를 가지고 있지 않는 경우
        - 객체 o에 프로퍼티 x를 만든 후 값을 설정한다.
    - 객체 o가 프로퍼티 x를 상속받은 경우
        - 기존에 상속받은 프로퍼티의 x 값은 새로 설정되는 값에 의해 잠시 가려지게 된다.
        - 객체의 프로퍼티에 값을 설정할 때는 해당 프로퍼티에 값을 설정할 수 있는지를 알아보기 위해 프로토타입 체인을 검사한다.
            1. ***객체 o가 읽기 전용 프로퍼티 x를 상속하는 경우에는 해당 프로퍼티에 값을 설정할 수 없다.***
            2. 하지만 객체의 프로퍼티에 값을 설정할 수 있다면, 기존의 프로토타입 체인을 수정하지 않고 객체에 해당 프로퍼티가 없다면, 이를 만들고 값을 설정한다.
    - 프로퍼티를 선택적으로 재정의할 수 있기 때문에, 객체에서 프로퍼티 값을 찾을 때 상속이 발생한다는 점은 자바스크립트가 가진 중요한 특징 중 하나이다.

3. 예외
    - 객체 o가 프로퍼티 x를 상위 객체로부터 상속 받았고, ***이 프로퍼티가 setter 메서드를 가진 접근자 프로퍼티***라고 가정하자.
    - 객체 o의 프로퍼티 x에 값을 설정할 때
        - 객체 o에 새 프로퍼티 x를 추가하지 않고 상속받은 프로퍼티 x가 가진 setter 메서드를 호출한다.
        - 하지만 setter 메서드는 프로퍼티 x가 정의된 프로로타입 객체에서 호출되지 않고 객체 o에서 직접 호출된다.
        - 따라서 setter 메서드는 객체 o에 임의의 프로퍼티를 정의할 수 있고, 객체의 프로로타입 체인도 변경하지 않는다.

### 3. 프로퍼티 접근 에러
1. 프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나 값을 설정할 수 있는 것은 아니다.
2. 종류
    - 객체 o가 고유 프로퍼티 p를 가지고 있고, 읽기 전용인 경우
        - 읽기 전용 프로퍼티 p에 값을 설정할 수 없다.
    - 객체 o는 상속된 프로퍼티 p를 가지고 있고, 프로퍼티 p가 읽기 전용인 경우
        - 동일한 이름의 고유 프로퍼티 p로 상속된 읽기 전용 프로퍼티 p를 숨길 수 없다.
    - 객체 o에 고유 프로퍼티 p가 없고, 프로퍼티 p를 상위 객체로부터 상속받지도 않았으며, 객체 확장 속성이 false인 경우
        - 만약 프로퍼티 p가 객체 o에 존재하지 않고, setter 메서드도 호출되지 않았다면 p는 반드시 객체 o에 추가되어야 한다. 하지만 객체 o가 확장할 수 없는 경우에는 새로운 프로퍼티도 추가할 수가 없다.

### 4. 프로퍼티 삭제하기
1. delete 연산자는 객체의 프로퍼티를 삭제한다.
2. delete 연산자는 설정된 값과 무관하게 프로퍼티 자체가 객체에 존재할 때 동작한다.
3. delete 연산자는 상속받은 프로퍼티가 아닌 고유 프로퍼티만 지울 수 있다.(상속받은 프로퍼티를 지우기 위해서는 해당 프로퍼티가 정의된 프로토타입 객체에서 지워야 한다.)

### 5. 프로퍼티 검사하기
1. 때때로 객체가 가진 프로퍼티들이 잘 설정되었는지, 다시 말해 주어진 이름의 프로퍼티를 갖고 있는지를 검사할 필요가 있다.
2. 연산자 종류
    - in
    - hasOwnProperty()
    - propertyIsEnumerable()
    - 단순히 프로퍼티에 접근하는 것
3. in
    - in 연산자 왼쪽에는 프로퍼티 이름이 문자열로 와야 하고, 오른쪽에는 객체가 와야 한다. 객체가 프로퍼티에 존재하면 true를 반환한다.
    - ```
        var o = {x: 1};
        'x' in o; //객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.
        'y' in o; //객체 o에 고유 프로퍼티 y가 존재하지 않아 false를 반환한다.
        'toString' in o; //객체 o에 상속받은 프로퍼티 toString가 있기 때문에 true를 반환한다.
        ```
4. hasOwnProperty()
    - 주어진 이름의 프로퍼티가 객체에 존재하는지를 검사한다. 상속받은 프로퍼티의 경우에는 false를 반환한다.
    - ```
        var o = {x: 1};
        o.hasOwnProperty('x')  //객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.
        o.hasOwnProperty('y') //객체 o에 고유 프로퍼티 y가 존재하지 않아 false를 반환한다.
        o.hasOwnProperty('toString') //toString은 상속된 프로퍼티이기 때문에 메서드는 false를 반환한다.
        ```

5. propertyIsEnumerable()
    - hasOwnProperty()로 테스트한 결과를 정제한다. 객체에 주어진 이름의 고유 프로퍼티가 존재하고, 열거할 수 있는 (enumerable 속성이 true인) 프로퍼티인 경우에만 true를 반환한다.
    - ```
        var o = inherit({y:2}); //{y:2}를 프로토타입으로 가지는 객체를 반환한다.
        o.x = 1;
        o.propertyIsEnumerable('x') // 객체 o에 열거할 수 있는 고유 프로퍼티 x를
        //가지고 있기 때문에 메서드는 true를 반환한다.
        o.propertyIsEnumerable('y') //프로퍼티 y는 상속받은 프로퍼티이기 때문에 메서드는 false를 반환한다.
        Object.prototype.propertyIsEnumerable('toString'); // toString은 내장 프로퍼티이고, 열거할 수 없기 때문에 메서드는 false를 반환한다.
        ```

### 6. 프로퍼티 열거하기


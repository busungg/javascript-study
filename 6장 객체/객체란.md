# 객체
1. 자바스크립트의 기본 데이터 타입은 객체다.
2. 객체는 이름과 값으로 구성된 프로퍼티들의 정렬되지 않은 집합이다.
    - 프로퍼티의 이름은 문자열이기 때문에, 객체는 문자열과 값이 연결된 집합이라고 할 수 있다.
    - 문자열 - 값 형태의 연결 구조는 기초 자료구조에서 해시, 해시 테이블, 사전, 연관배열로 소개하고 있다.
3. 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 **'프로토타입'이라고 하는 다른 객체의 프로퍼티를 상속받는다. 객체의 메서드들은 일반적으로 상속받은 프로퍼티이고, 이를 '프로토타입 상속'이라고 한다. 프로토타입 상속은 자바스크립트의 핵심 기능이다.**
4. 자바스크립트에서는 문자열, 숫자, true/false 와 null/undefined를 제외한 나머지는 객체다. 비록 문자열과 숫자, 불리언 값은 객체는 아니지만 값이 정해진 객체로 취급된다.
5. 객체의 각 프로퍼티는 이름과 값 외에 '프로퍼티 속성'이라고 하는 연관된 값을 갖는다.
    - 쓰기(writable) 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.
    - 열거(enumerable) 속성은 프로퍼티의 이름을 for/in 루프에서 읽을 수 있는지 여부를 결정한다.
    - 설정(configurable) 속성은 프로퍼티의 삭제 가능 여부와 프로퍼티 속성의 변경 여부를 결정한다.
6. 객체의 프로퍼티 뿐 아니라, 모든 객체는 세 가지의 속성을 갖는다.
    - 객체의 prototype은 상속받은 프로퍼티들을 가진 객체에 대한 참조변수다.
    - 객체의 class는 객체의 유형을 뷴류하는 문자열이다.
    - ECMAScript 5에서 객체의 extensible 플래그는 객체에 새 프로퍼티의 추가 여부를 결정한다.

### 객체 용어
1. 네이티브 객체
    - ECMAScript 명세에 정의된 객체이거나 객체의 글래스다.  
    Array, Function, Date, 정규 표현식들은 전부 네이티브 객체다.
2. 호스트 객체
    - 브라우저와 같이 자바스크립트 인터프리터가 내장된 호스트 환경에 정의된 객체다. HTMLElement 객체는 웹페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체다. 호스트 객체는 호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 함수 객체로 정의 하는 것과 마찬가지로 네이티브 객체일 수도 있다.
3. 사용자 정의 객체
    - 자바스크립트 코드의 실행으로 생성된 객체다.
4. 고유 프로퍼티
    - 객체에 직접 코드로 정의한 프로퍼티이다.
5. 상속받은 프로퍼티
    - 객체 프로토타입 객체에 의해 정의된 프로퍼티를 말한다.

# 객체 생성하기
1. 객체는 객체 리터럴 또는 new 키워드를 이용해 생성될 수 있고, ECMAScript 5의 Object.create() 함수를 통해 생성될 수도 있다.

### 1. 객체 리터럴
1. 객체 리터럴은 리터럴이 평가되는 시점에 새로운 객체가 생성됨과 동시에 초기화되는 표현식이다.
    - ```
        var empty = {}; // 프로퍼티가 없는 빈 객체
        var point = {x: 0, y: 0} // 두 개의 프로퍼티 x,y를 정의한다.
        var point2 = {x: point.x, y: point.y + 1} // 프로퍼티를 수식 값으로 정의한다.
        var book = {
            'main title' : 'Javascript' //프로퍼티 이름은 공백과
            'sub-title' : 'The Definitive Guide' // 하이픈(-)을 포함할 수 있다.
            'for': 'all' //예약어인 for도 인용부호를 둘러싸서 문자열 리터럴로 사용할 수 있다.
            author: { //프로퍼티 author의 값은 객체 그 자체다.
                firstName: 1, //프로퍼티 이름은 인용부호로 감싸지 않을수도 있다.
                surname: 2
            }

        }
        ```
2. ECMAScript 5에서 객체 리터럴의 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시한다.

### 2. new를 사용해 객체 생성하기
1. new 연산자로 객체를 만들고, 초기화할 수 있다.
2. new 키워드는 반드시 함수 호출 다음에 와야한다. 이때 사용되는 함수를 생성자라고 하는데, 새로 생성된 객체를 초기화하는 역할을 한다.

### 3. 프로토타입
1. 자바스크립트의 모든 객체는 두 번째 자바스크립트 객체(극히 드물지만 null일 수도 있다.)와 연관되어 있다. 이 두 번째 객체는 프로토타입으로 알려져 있고, 이때 첫 번째 객체는 프로토타입으로부터 프로퍼티들을 상속 받는다.
2. 객체 리터럴 생성 시 프로토타입 객체
    - Object.prototype
3. new 키워드 객체 생성 시 프로토타입 객체
    - 생성자의 프로토타입을 자신의 프로토타입으로 하는 객체가 생성된다.
4. Object.prototype은 prototype이 없다.
5. 프로토타입 체인
    - 프로토타입 객체들의 연속된 연결을 '프로토타입 체인'이라고 한다.

### 4. Object.create()
1. Object.create 메서드의 첫 번째 인자로 프로토타입 객체를 전달할 수 있고, 두 번째 인자는 새 객체의 프로퍼티 정보를 가진 객체로 전달 할 수 있으나 생략 가능하다.
2. Object.create()는 정적(static) 함수로, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서 단순히 프로토타입 객체를 넘기기만 하면 된다.
    - ```
        var o1 = Object.create({x:1, y:2});
        ```
3. 프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다. 하지만 이 경우에는 새롭게 생성된 객체가 어떠한 객체도 상속받지 않기 때문에 toString() 메서드와 같은 기본적인 메서드조차 사용할 수 없다. 다시 말해, + 연산자 또한 사용할 수 없다.
    - ```
        var o2 = Object.create(null);

        var o3 = Object.create(Object.prototype);
        //o3는 {} 또는 new Object()와 같은 객체다.
        ```

# 프로퍼티 접근 및 설정
1. 프로퍼티 값을 가져오기 위해서는 마침표(.) 연산자 또는 대괄호([]) 연산자를 사용한다.
2. 프로퍼티를 만들거나 설정하기 위해서는 객체의 프로퍼티에 접근하는 것과 동일하게 마침표 연산자 또는 대활호 연산자를 사용한다. 이때 프로퍼티는 할당 표현식의 오른쪽에 위치한다.
    - ```
        book.edition = 6;
        book['main title'] = 'abc';
        ```

### 1. 연관 배열로서의 객체
1. 마침표(.) 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름이 반드시 식별자로 표현되어야한다. 식별자는 데이터 타입이 아니라 자바스크립트 프로그램에 직접 작성한 이름이기 때문에 프로그램이 실행될 때 변경할 수 없다.
2. 반면에 [] 연산자를 사용해 객체의 프로퍼티에 접근할 때는 프로퍼티의 이름이 문자열로 표현된다. 문자열은 자바스크립트의 데이터 타입이기 때문에 프로그램 실행 시점에 생성되고 중간에 변경될 수 있다.
    - ```
        var addr = '';
        for(i = 0; i < 4; i++) {
            addr += customer['address' + i ] + '\n';
        }
        ```

### 2. 상속
1. 자바스크립트 객체는 고유 프로퍼티들을 가지고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티들을 상속받는다.
    - 예를 들어 객체 o.에서 프로퍼티 x를 찾는다고 하자.
    - 객체 o가 프로퍼티 x를 갖고 있지 않으면
    - ***o의 프로토타입 객체에서 x를 찾는다.***
    - 만약 프로로타입 객체에 고유 프로퍼티 x가 없다면
    - ***상위 객체의 프로로타입 객체에서 프로퍼티 x를 찾는다***
    - 이러한 작업은 ***프로퍼티 x를 찾거나 해당 객체 또는 객체의 프로토타입 객체가 null이 될 때까지 계속된다.***
    - 이처럼 객체의 프로토타입 속성은 특정 프로퍼티가 어떤 객체에 속해 있는지 알 수 있는 프로퍼티 체인 또는 연결 리스트를 생성한다.
    - ```
        var o = {}; //o는 Objejct.prototype을 상속받은 객체고,
        o.x = 1; //고유 프로퍼티 x를 갖는다.
        var p = inherit(o); //p는 객체 o와 Object.prototype을 상속받는 객체고,
        p.y = 2; //고유 프로퍼티 y를 갖는다.
        var q = inherit(p); //q는 객체 p와 o, Object.prototype을 상속받는 객체고,
        q.z = 3; // 고유 프로퍼티 z를 갖는다.
        var s = q.toString(); // q는 Object.prototype을 상속받았기 때문에 toString() 을 사용할 수 있었다.
        q.x + q.y; //결과는 3이고, q의 프로퍼티 x와 y는 각각 객체 o와 p에서 상속받았다.
        ```
2. 객체 o의 프로퍼티 x에 값을 설정해보자.
    - 객체 o가 상속받지 않은 고유 프로퍼티 x를 가지고 있는 경우
        - 기존의 프로퍼티 값을 단순히 바꿀 수 있다.
    - 프로퍼티 x를 가지고 있지 않는 경우
        - 객체 o에 프로퍼티 x를 만든 후 값을 설정한다.
    - 객체 o가 프로퍼티 x를 상속받은 경우
        - 기존에 상속받은 프로퍼티의 x 값은 새로 설정되는 값에 의해 잠시 가려지게 된다.
        - 객체의 프로퍼티에 값을 설정할 때는 해당 프로퍼티에 값을 설정할 수 있는지를 알아보기 위해 프로토타입 체인을 검사한다.
            1. ***객체 o가 읽기 전용 프로퍼티 x를 상속하는 경우에는 해당 프로퍼티에 값을 설정할 수 없다.***
            2. 하지만 객체의 프로퍼티에 값을 설정할 수 있다면, 기존의 프로토타입 체인을 수정하지 않고 객체에 해당 프로퍼티가 없다면, 이를 만들고 값을 설정한다.
    - 프로퍼티를 선택적으로 재정의할 수 있기 때문에, 객체에서 프로퍼티 값을 찾을 때 상속이 발생한다는 점은 자바스크립트가 가진 중요한 특징 중 하나이다.

3. 예외
    - 객체 o가 프로퍼티 x를 상위 객체로부터 상속 받았고, ***이 프로퍼티가 setter 메서드를 가진 접근자 프로퍼티***라고 가정하자.
    - 객체 o의 프로퍼티 x에 값을 설정할 때
        - 객체 o에 새 프로퍼티 x를 추가하지 않고 상속받은 프로퍼티 x가 가진 setter 메서드를 호출한다.
        - 하지만 setter 메서드는 프로퍼티 x가 정의된 프로로타입 객체에서 호출되지 않고 객체 o에서 직접 호출된다.
        - 따라서 setter 메서드는 객체 o에 임의의 프로퍼티를 정의할 수 있고, 객체의 프로로타입 체인도 변경하지 않는다.

### 3. 프로퍼티 접근 에러
1. 프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나 값을 설정할 수 있는 것은 아니다.
2. 종류
    - 객체 o가 고유 프로퍼티 p를 가지고 있고, 읽기 전용인 경우
        - 읽기 전용 프로퍼티 p에 값을 설정할 수 없다.
    - 객체 o는 상속된 프로퍼티 p를 가지고 있고, 프로퍼티 p가 읽기 전용인 경우
        - 동일한 이름의 고유 프로퍼티 p로 상속된 읽기 전용 프로퍼티 p를 숨길 수 없다.
    - 객체 o에 고유 프로퍼티 p가 없고, 프로퍼티 p를 상위 객체로부터 상속받지도 않았으며, 객체 확장 속성이 false인 경우
        - 만약 프로퍼티 p가 객체 o에 존재하지 않고, setter 메서드도 호출되지 않았다면 p는 반드시 객체 o에 추가되어야 한다. 하지만 객체 o가 확장할 수 없는 경우에는 새로운 프로퍼티도 추가할 수가 없다.

### 4. 프로퍼티 삭제하기
1. delete 연산자는 객체의 프로퍼티를 삭제한다.
2. delete 연산자는 설정된 값과 무관하게 프로퍼티 자체가 객체에 존재할 때 동작한다.
3. delete 연산자는 상속받은 프로퍼티가 아닌 고유 프로퍼티만 지울 수 있다.(상속받은 프로퍼티를 지우기 위해서는 해당 프로퍼티가 정의된 프로토타입 객체에서 지워야 한다.)

### 5. 프로퍼티 검사하기
1. 때때로 객체가 가진 프로퍼티들이 잘 설정되었는지, 다시 말해 주어진 이름의 프로퍼티를 갖고 있는지를 검사할 필요가 있다.
2. 연산자 종류
    - in
    - hasOwnProperty()
    - propertyIsEnumerable()
    - 단순히 프로퍼티에 접근하는 것
3. in
    - in 연산자 왼쪽에는 프로퍼티 이름이 문자열로 와야 하고, 오른쪽에는 객체가 와야 한다. 객체가 프로퍼티에 존재하면 true를 반환한다.
    - ```
        var o = {x: 1};
        'x' in o; //객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.
        'y' in o; //객체 o에 고유 프로퍼티 y가 존재하지 않아 false를 반환한다.
        'toString' in o; //객체 o에 상속받은 프로퍼티 toString가 있기 때문에 true를 반환한다.
        ```
4. hasOwnProperty()
    - 주어진 이름의 프로퍼티가 객체에 존재하는지를 검사한다. 상속받은 프로퍼티의 경우에는 false를 반환한다.
    - ```
        var o = {x: 1};
        o.hasOwnProperty('x')  //객체 o에 고유 프로퍼티 x가 존재하므로 true를 반환한다.
        o.hasOwnProperty('y') //객체 o에 고유 프로퍼티 y가 존재하지 않아 false를 반환한다.
        o.hasOwnProperty('toString') //toString은 상속된 프로퍼티이기 때문에 메서드는 false를 반환한다.
        ```

5. propertyIsEnumerable()
    - hasOwnProperty()로 테스트한 결과를 정제한다. 객체에 주어진 이름의 고유 프로퍼티가 존재하고, 열거할 수 있는 (enumerable 속성이 true인) 프로퍼티인 경우에만 true를 반환한다.
    - ```
        var o = inherit({y:2}); //{y:2}를 프로토타입으로 가지는 객체를 반환한다.
        o.x = 1;
        o.propertyIsEnumerable('x') // 객체 o에 열거할 수 있는 고유 프로퍼티 x를
        //가지고 있기 때문에 메서드는 true를 반환한다.
        o.propertyIsEnumerable('y') //프로퍼티 y는 상속받은 프로퍼티이기 때문에 메서드는 false를 반환한다.
        Object.prototype.propertyIsEnumerable('toString'); // toString은 내장 프로퍼티이고, 열거할 수 없기 때문에 메서드는 false를 반환한다.
        ```

### 6. 프로퍼티 열거하기
1. 객체가 가진 모든 프로퍼티를 순회하고 싶을 때 보통의 경우 for/in 루프로 해결한다.
    - for/in 루프는 상속받은 내장 메서드는 열거할 수 없지만, 사용자가 임의로 추가한 프로퍼티들은 객체 내에서 열거할 수 있다.
    - ```
        for( p in o ) {
            if(!o.hasOwnProperty(p)) { //상속받은 프로퍼티 생략
                continue;
            }
        }

        for(p in o) {
            if(typeof o[p] === 'function') { //해당 프로퍼티가 메서드면 생략 한다.
                continue;
            }
        }
        ```
2. for/in 루프를 비롯해, ECMAScript 5에는 프로퍼티 이름을 열거하는 두가지 함수가 존재한다.
    - Object.keys() 함수
        - 객체가 가진 고유 프로퍼티 중에 열거할 수 있는 프로퍼티 이름을 배열에 담아 반환한다.
    - Object.getOwnPropertyNames()
        - 해당 객체가 가진 모든 고유 프로퍼티의 이름을 배열로 반환한다.

### 7 Getter와 Setter 프로퍼티
1. ECMAScript 5에서는 프로퍼티의 값을 getter/setter 메서드로 대체할 수 있다. 이때, ***getter/setter 메서드로 정의된 프로퍼티는 단순히 값을 갖는 '데이터 프로퍼티'와는 다른 '접근자 프로퍼티'라고 한다.***
2. 프로그램이 객체의 프로퍼티 값에 접근할 때, 자바스크립트 엔진은 getter 메서드를 아무런 인자 없이 호출한다. 이때, getter 메서드의 반환값은 프로퍼티 접근 표현식의 값이 된다.
3. 프로그램이 프로퍼티의 값을 변경할 때, 자바스크립트 엔진은 setter 메서드를 호출한다. 이때 할당자(=)의 오른쪽에 있는 값을 setter 메서드의 인자로 전달한다. setter 메서드는 프로퍼티의 값을 '설정'하는 것을 담당하고, 메서드의 반환 값은 무시된다.
4. 데이터 프로퍼티가 writable(쓰기) 속성을 갖는 반면, 접근자 프로퍼티는 쓰기 속성을 갖지 않는다.
    - 만약 프로퍼티가 getter/setter 메서드를 모두 가지고 있으면, 읽기/쓰기 모두 가능하다.
    - 프로퍼티가 getter 메서드만 가지고 있다면, 읽기 전용 프로퍼티다.
    - 프로퍼티가 setter 메서드만 가지고 있다면, 쓰기 전용 프로퍼티고, 이때 읽기를 시도하면 항상 undefined가 반환된다.
5. 정의 방법
    - ```
        var o = {
            //데이터 프로퍼티
            data_prop: value,

            //한 쌍의 함수로 정의된 접근자 프로퍼티
            get accessor_prop() { /* 함수 몸체 */ },
            set accessor_prop(value) { /* 함수 몸체 */ }
        };

        //함수 정의에 사용되는 'function' 키워드 대신 get/set을 사용한다. 이때, 기존 객체 프로퍼티 정의와는 달리 프로퍼티 이름 뒤에 콜론을 사용하지 않는다.


        var p = {
            //읽기/쓰기 속성을 가진 일반적인 데이터 프로퍼티 x,y
            x: 1.0,
            y: 1.0,
            // r은 getter/setter를 통한 읽기/쓰기가 가능한 접근자 프로퍼티다.
            //이러한 접근자 메서드 다음에 쉼표를 반드시 추가해야한다.
            get r() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            set r(newValue) {
                var oldValue = Math.sqrt(this.x * this.x + this.y * this.y);
                var ratio = newValue / oldValue;
                this.x *= ratio;
                this.y *= ratio;
            },
            //theta는 읽기 전용 접근자 프로퍼티고, getter 함수만 갖는다.
            get theta() {
                return Math.atan2(this.y, this.x);
            }
        }

        //객체 P에서 getter와 setter함수 몸체에서 this 키워드를 사용했다.
        // 자바스크립트는 getter/setter 함수가 객체에 정의된 순간, 이들 함수를 호출할 때 객체의 메서드로서 호출한다.
        //이는 함수의 몸체 안에 사용된 this 키워드가 객체 자신을 가리킨다는 뜻이다.
        ```
    6. 접근자 프로퍼티는 데이터 프로퍼티와 마찬가지로 상속할 수 있어서 예제에 정의된 객체 P는 다른 좌표의 프로토타입으로 사용할 수 있다.
        - ```
            var q = inherit(p); //객체 p의 getter와 setter를 상속받는 객체 q를 생성한다.
            q.x = 1; q.y = 1; //객체 q에 고유 데이터 프로퍼티들을 만든 후
            console.log(q.r); //상속받은 접근자 프로퍼티를 사용한다.
            ```

### 8. 프로퍼티 속성
1. 프로퍼티 이름과 값 뿐 아니라, 프로퍼티 그 자체를 결정하는 ***세 가지 속성 writable과 enumerable, configurable***이 있다.
    - writable
        - writable 속성은 프로퍼티 값의 변경 여부를 결정한다.
    - enumerable
        - 프로퍼티가 열거될 수 있는지 여부를 결정한다.
    - configurable
        - configurable 속성은 configurable 속성 뿐 아니라 writable 속성과 enumerable 속성 값의 변경 여부를 결정한다.
    - 추가로 데이터 프로퍼티의 값 또한 속성이라고 할 수 있으므로 value도 포함 시킬 수 있다. 또한 접근자 프로퍼티는 value 속성이나 writable 속성을 갖지 않는데, writable 속성은 setter 메서드의 존재 여부에 따라 결정되기 때문이다. 따라서 접근자 프로퍼티의 네 가지 속성은 get, set, enumerable, configurable 이다.
2. 라이브러리를 만들 경우 프로퍼티의 세 가지 속성 값을 질의하고, 값을 설정하는 ECMAScript 5의 API는 중요하다.
    - 프로토타입 객체에 메서드를 추가하도록 설정할 수 있고, 추가된 메서드를 내장 메서드처럼 여러할 수 없게 만들 수 있다.
    - 객체를 변경하거나 삭제할 수 없도록 고정(lock down) 시킬 수 있다.

4. 프로퍼티 디스크립터(Property Descriptor)
    - 프로퍼티의 속성 값을 질의하고, 값을 설정하는 ECMAScript 5의 객체이다.
    - 프로퍼티 디스크립터 객체는 임의의 프로퍼티가 가진 속성과 그 값들을 하나의 객체로 관리한다.
    - 예를 들어 데이터 프로퍼티의 디스크립터 객체는 value, writable, enumerable, configurable 이름의 프로퍼티를 갖는다.
    - 접근자 프로퍼티의 디스크립터 객체는 value와 writable 대신 get과 set 프로퍼티를 갖는다.
    - ***writable, enumerable, configurable 프로퍼티는 boolean 값을 갖고 get과 set 프로퍼티는 당연히 function 값을 갖는다.***
    - ***객체가 가진 특정 프로퍼티에 대한 프로퍼티 디스크립터 객체는 Object.getOwnPropertyDescriptor()를 통해 얻을 수 있다.
        - ```
            // {value:1, writable:true, enumerable:true, configurable: true}를 반환한다.
            Obejct.getOwnPropertyDescriptor({x:1}, 'x');

            //상속받은 프로퍼티나 존재하지 않는 프로퍼티인 경우 undefined를 반환한다.

            //{get: ƒ, set: undefined, enumerable: true, configurable: true}
            console.log(Object.getOwnPropertyDescriptor(p, 'theta'));
            ```
        - Object.getOwnPropertyDescriptor()는 그 이름에서 알 수 있듯이 객체의 고유 프로퍼티에서만 동작한다. 상속된 프로퍼티의 속성을 검사하기 위해서는 프로토타입 체인을 반드시 순회해야 한다. (Object.getPrototypeOf()를 살펴보자)
    - Object.defineProperty()
        - 프로퍼티의 속성을 설정하거나 임의의 속성으로 새 프로퍼티를 만들기 위해 호출한다.
        - 함수의 인자로, 수정할 객체와 추가하거나 변경할 프로퍼티 이름, 프로퍼티의 디스크립터 객체를 넘긴다.
        - ```
            var o = {};

            /열거할 수 없는 데이터 프로퍼티 x를 정의하고 프로퍼티의 값을 1로 설정한다.
            Object.defineProperty(o, 'x', {
                value: 1,
                writable: true,
                enumerable: false,
                configurable: true
            });

            //정의한 프로퍼티를 열거할수 있는지 검사한다.
            o.x;
            Object.keys(o) // => []

            //프로퍼티 값을 바꿔보자
            Object.defineProperty(o, 'x', {writable: false});

            o.x = 2; //엄격한 모드에서는 단순히 값을 변경하지 못하거나 TypeError 예외가 발생한다.
            o.x // => 1

            //프로퍼티는 여전히 configurable 속성을 갖고 있어서 다음과 같이 기존 값을 바꿀 수 있다.
            Object.defineProperty(o, 'x', {value: 2});
            o.x // => 2

            //프로퍼티 x를 데이터 프로퍼티에서 접근자 프로퍼티로 바꿨다.
            Object.defineProperty(o, 'x', {
                get: function() {return 0;}
            });
            o.x // => 0
            ```
        - 인자로 넘긴 프로퍼티 디스크립터 객체에 반드시 네 개의 프로퍼티가 있어야 할 필요는 없다. 만약 새 프로퍼티를 만들때, 프로퍼티 디스크립터 객체에 생략된 속성은 false나 undefined로 처리된다. 기존 프로퍼티의 속성을 수정할 경우, 생략한 속성은 기존 값을 그대로 유지한다.
        - Object.defineProperty() 메서드는 기존 프로퍼티나 새로 만든 고유 프로퍼티의 속성을 바꾸지만, 상속받은 속성은 바꾸지 않는다.
    - Object.defineProperties()
        - 동시에 여러 개의 프로퍼티를 만들거나 수정하고 싶을 때 사용한다.
        - 이 메서드의 첫 번째 인자는 수정하려는 객체다. 두 번째 인자는 객체에 만들거나 수정하려는 프로퍼티 이름과, 프로퍼티 디스크립터 객체를 값으로 갖는 객체다.
        - ```
            var p = Object.defineProperties({}, {
                x: {value: 1, writable: true, enumerable: true, configurable: true},
                y: {value: 1, writable: true, enumerable: true, configurable: true},
                r: {
                    get: function() {return Math.sqrt(this.x * this.x + this.y * this.y)},
                    enumerable: true,
                    configurable: true
                }
            });
            ```
    - TypeError 예외가 발생하는 경우
        1. 객체를 확장할 수 없으면, 고유 프로퍼티를 수정할 수는 있지만 새 프로퍼티를 추가할 수는 없다.
        2. 프로퍼티의 configurable속성 값이 false면, configurable 속성 값 뿐 아니라 enumerable 속성 값도 바꿀 수 없다.
        3. 접근자 프로퍼티의 configurable 속성 값이 false면, 본래 getter/setter 메서드와 데이터 프로퍼티 또한 바꿀 수 없다.
        4. 데이터 프로퍼티의 configurable 속성 값이 false면, 데이터 프로퍼티를 접근자 프로퍼티로 바꿀 수 없다.
        5. 데이터 프로퍼티의 configurable 속성 값이 false면, 기존의 writable 속성을 false에서 true로 바꿀 수 없다. 하지만 true에서 false로 바꾸는 것은 가능하다.
        6. 데이터 프로퍼티의 configurable 속성 값과 writable 속성 값이 false면, 프로퍼티 값을 바꿀수 없다. 하지만 프로퍼티의 configurable 속성 값이 true고, writable 속성 값이 false인 경우에는 프로퍼티의 값을 바꿀 수 있다.
    - 기타 프로퍼티 속성까지 복사하는 Extend 함수 P177

# 객체 속성
### 1. prototype 속성
1. 객체의 프로토타입 속성은 프로퍼티를 상속하는 객체를 지정한다.
2. prototype 속성은 객체가 만들어지는 시점에 설정된다.
    - 객체 리터럴을 통해 만든 객체는 Object.prototype을 객체의 프로토타입으로 설정한다.
    - new를 사용해 만든 객체는 프로토타입으로 사용할 생성자 함수의 prototype 프로퍼티 값을 사용한다.
    - Object.create() 메서드로 만든 객체는 메서드의 첫 번째 인자로 넘긴 함수를 객체의 프로토타입으로 사용한다.
3. ECMAScript 5에서는 ***Object.getPrototypeOf()에 객체를 전달해 객체의 프로토타입을 검사***할 수 있다. ECMAScript 3에는 ***o.constructor.prototype 표현식***을 사용할 수 있다.
4. 객체 A가 객체 B의 프로토타입(또는 프로토타입 체인의 일부)인지 알아보기 위해서는 isPrototypeOf() 메서드를 사용한다. 객체 p가 객체 o의 프로토타입인지 확인하려면 p.isPrototypeOf(o)를 사용한다.
    - ```
        var p = {x:1};
        var o = Object.create(p); //객체 p를 프로토타입으로 하는 객체를 만든다.
        p.isPrototypeOf(o); // true: 객체o는 객체 p를 상속받는다.
        Object.prototype.isPrototypeOf(p) // true: 객체 p는 Object.prototype을 상속 받는다.
        ```
### 2. class 속성
1. class 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다. 
ECMAScript 3과 ECMAScript 5 모두 어떠한 방법으로도 이 속성을 변경할 수 없고, 단순히 간접적인 방법으로 값을 질의할 수만 있다.
2. 객체의 클래스 정보를 알아보기 위해서는 객체의 toString() 메서드를 호출하면 된다. 이때 반환되는 스트링의 아홉 번째 문자부터 문자열 끝에서 두 번째 문자까지 추출한다.

### 3. extensible 속성
1. 객체의 extensible 속성은 객체에 새 프로퍼티를 추가할지 여부를 결정한다.
# Window 객체

1. Window 객체의 주 역할은 클라이언트 측 자바스크립트 프로그램의 전역 객체이다.  
   이번 장에서는 Window 객체의 프로퍼티와 메서드에 대해 다룬다.  
   Window 객체의 프로퍼티들은 매우 많은 API로 이루어져 있는데, Window 객체라는 이름을 갖게 된 이유는 해당 프로퍼티 중 일부가 실제로 브라우저의 창과 관련있기 때문이다.
2. 목차
   - setTimeout()과 setInterval()을 사용하여 특정 시점에 호출할 함수를 등록하는 방법을 설명한다.
   - location 속성을 사용하여 현재 문서의 URL을 가져오거나 새로운 문서를 불러오는 방법을 설명한다.
   - history 속성을 다루어 브라우징 히스토리 정보를 바탕으로 브라우저에서 뒤로 가기와 앞으로 가기를 구현하는 방법을 설명한다.
   - navigator 속성을 사용하여 브라우저 제조사와 버전 정보 등을 알아내고, screen 속성을 사용하여 데스크톱의 크기를 얻어오는 방법을 설명한다.
   - alert()와 confirm(), prompt() 메서드를 사용하여 간단한 대화상자를 보여주는 방법과 showModalDialog()를 사용해 HTML: 대화상자를 보여주는 방법을 설명한다.
   - 예기치 못한 자바스크립트 오류가 발생했을 때 호출되는 onerror 이벤트 핸들러를 등록하는 방법을 설명한다.
   - HTML 요소의 ID와 name을 Window 객체의 속성으로 사용하는 방법에 대해 설명한다.
   - 브라우저 창을 열고 닫으며 여러개의 창과 프레임 간에서 동작 가능한 자바스크립트 코드를 작성하는 방법을 설명한다.

# 브라우저의 Location과 Navigation

1. Window 객체의 location 프로퍼티는 현재 창에 표시된 문서의 URL을 나타내는 Location 객체와 연결되어 있으며, 또한 이 객체에는 해당 창에 새 문서를 불러들이는 메서드도 존재한다.
2. Document 객체의 loaction 프로퍼티도 역시 동일한 Location 객체와 연결되어 있다.
   - ```
        window.location === document.location
     ```
   - Document 객체에는 문서가 처음 로드될 때 해당 문서의 URL을 정적 문자열로 저장한 URL 프로퍼티도 존재한다. 문서를 #table-of-contens와 같은 부분 식별자로 탐색하면, Location 객체에는 이것이 반영되지만, document.URL 프로퍼티의 값은 변경되지 않는다.

### 1. URL 파싱

1. Window 객체의 location 프로퍼티는 Location 객체를 가리킨다. Location 객체는 창에 표시되고 있는 현재 문서의 URL을 나타낸다.
2. Location 객체 프로퍼티
   - href 프로퍼티에는완전한 URL 문자열이 저장되어 있다.
   - toString() 메서드는 href 프로퍼티의 값을 반환한다.
   - protocol과 host, hostname, port, pathname, search, hash와 같이 이 객체의 다른 프로퍼티들은 URL의 다양한 특성을 나타낸다. 이것들을 'URL 분해' 속성이라고 부르며 Link 객체에서도 제공된다.(HTML 문서의 \<a> 와 \<area> 요소에서 생성된다.)
   - hash와 search는 흥미로운 프로퍼티 중 하나다. hash 프로퍼티는 URL의 '부분 식별자'를 반환한다. 부분 식별자가 존재한다면 해시 마크(#)의 뒷부분은 요소의 ID일 것이다.
   - search 프로퍼티도 비슷한데, URL의 일부 중 물음표(?)로 시작되는 부분을 반환한다. 대부분 쿼리 스트링 값이다. 일반적으로 전달인자를 포함하기 위해서 이부분을 URL 매개변수로 활용한다.

### 2. 새 문서 불러오기

1. Location 객체의 assign() 메서드는 창을 불러와서 지정된 URL에 해당되는 문서를 보여준다. replace() 메서드도 비슷하지만, 새 문서를 불러오기 전에 브라우저 히스토리 상의 현재 문서를 제거한다는 차이점이 있다. 스크립트로 새 문서를 무조건 불러와야 할 경우, assign() 보다 replace() 메서드를 사용하는 편이 좋다. 뒤로 가기 버튼은 브라우저를 이전 문서로 이동시키고 해당 문서의 스크립트를 다시 불러오므로, location.replace()를 사용하여 웹 페이지의 모든 기능을 보여주기 힘든 브라우저에 대응하는 정적 버전 HTML을 불러 올 수도 있을 것이다.
   - ```
        //브라우저가 XMLHttpRequest 객체를 지원하지 않는다면
        //이 객체를 사용하지 않는 정적인 페이지로 이동시킨다.
        if(!XMLHttpRequest) location.replace('staticpage.html');
     ```
   - **_replace()로 전달되는 URL은 상대적으로 해석됨을 유념해야 한다. 상대 URL은 현재 보고 있는 페이지를 기준으로 해석되며, 주로 하이퍼링크에서 사용한다._**
2. assign()과 replace() 메서드 뿐만 아니라 Location 객체에는 브라우저가 문서를 다시 불러오도록 하는 reload() 메서드도 존재한다.
3. 전통적인 방법으로 브라우저를 새 페이지로 이동시키려면, 새로운 URL을 location 속성에 직접 지정해도 된다.

   - ```
        location = 'http://www.oreilly.com'

        //location에 상대 URL을 지정할 수도 있다. 이 URL은 현재 URL에 따라 결정된다.
        location = 'page2.html';
     ```

4. 기본적으로 부분 식별자는 브라우저에 새 문서를 불러오지 않고 단지; 문서의 새로운 절로 스크롤을 이동시키는 특별한 종류의 상대 URL이다. #top 구분자는 좀더 특별한 경우인데, 문서상에 top이라는 ID를 가진 요소가 없다면 브라우저를 문서의 시작점으로 스크롤한다.
   - ```
        location = '#top'; //문서의 상단으로 이동한다.
     ```
5. Location 객체의 URL 분해 속성은 쓰기가 가능하며, location URL을 변경하여 브라우저가 새 문서를 불러오도록 설정한다.(또는 hash 프로퍼티일 경우 현재 문서 내에서 이동하도록 한다).
   - ```
        location.search = '?page=' + (pagenum + 1); //다음 페이지를 불러온다.
     ```

### 3. 브라우징 히스토리

1. Window 객체의 history 프로퍼티는 History 객체를 가리킨다. History 객체 모델은 브라우징 히스토리를 문서와 문서 상태 목록으로 저장한다. History 객체의 length 프로퍼티는 브라우징 히스토리 목록의 갯수를 나타낸다. 그러나 저장된 URL에 접근하는 것은 보안상의 이유로 허용되지 않는다.(이를 허용한다면 아무 스크립트라도 여러분의 브라우징 히스토리를 돌아다닐 수 있다.)
2. History 객체에는 브라우저의 뒤로 가기와 앞으로 가기 버튼처럼 동작하는 back()과 forward() 메서드가 존재한다. 이 메서드를 사용하면 브라우정 히스토리상에서 한 단계씩 앞으로 또는 뒤로 이동할 수 있다. 세 번째로 go() 메서드가 있는데, 정수를 인자로 받아 히스토리 목록의 몇 단계씩을 앞으로(양수 인자) 또는 뒤로(음수 인자) 이동한다.
   - ```
        history.go(-2) //뒤로 가기 버튼을 두 번 누른 것처럼, 두 페이지 전으로 이동한다.
     ```
3. 창이 자식 창을 포함할 때는 (\<iframe> 요소 같이), 자식 창의 브라우징 히스토리는 시간 순으로 메인 창의 히스토리에 배치된다. 예를 들어 history.back()을 메인 창에서 호출하면 자식 창 중 하나가 이전 문서를 보여주려고 뒤로 이동하지만, 히스토리의 현재 상태는 메인 창을 유지한다.
4. 현대적인 웹 애플리케이션은 새 문서를 불러오지 않고도 내용을 동적으로 변경할 수 있다. 애플리케이션에서도 사용자가 뒤로 가기와 앞으로 가기 버튼을 눌었을 때, 동적으로 변경된 상태를 오가는 기능이 필요할지도 모른다. HTML5에서는 이 기능을 위해 두가지 기술을 표준화했다. 이 기술에 대해서는 22.2절에서 다룬다.

### 4. 브라우저 화면 정보

1. 스크립트에서는 종종 브라우저가 어떤 환경에서 실행되고 있는지 또는 데스크탑 내의 어느 위치에 표시되고 있는지에 대한 정보가 필요하다. 이 절에서는 Window 객체의 navigator와 screen 프로퍼티에 대해 다룬다. 이 프로퍼티들은 각각 Navigator와 Screen 객체를 가리키며, 해당 환경에 따라 행동을 사용자화 할 수 있도록 하는 정보를 제공한다.

### 1. Navigator 객체

1. Window 객체의 navigator 프로퍼티는 브라우저 제조사와 버전 정보를 포함하고 있는 Navigator 객체를 가리킨다.

   - appName
     - 웹브라우저의 전체 이름이다. 이 프로퍼티는 IE에서 'Microsoft Internet Explorer'이고 파이어폭스에서는 'Netscape'이다. 브라우저 호환성을 위해 종종 다른 브라우저에서도 스니핑 코드를 'Netscape'로 표시하기도 한다.
   - appVersion
     - 이 프로퍼티는 보통 숫자로 시작하며, 브라우저 제조사와 버전 정보 등을 포함한 문자열이 뒤따른다.
   - userAgent
     - 브라우저가 USER-AGENT HTTP 헤더로 보낸 문자열이다. 이 프로퍼티는 보통 appVersion에 있는 모든 정보 뿐만 아니라 부가적으로 상세 정보를 포함하기도 한다. appVersion과 마찬가지로 표준 형식은 없다. 이 프로퍼티가 대부분의 정보를 포함하고 있기 때문에 보통 브라우저 스니핑 코드에서 이 정보를 이용한다.
   - platform
     - 브라우저를 실행하고 있는 운영체제(아마 하드웨어까지도)를 식별하는 문자열이다.

2. Navigator 객체에는 브라우저 제조사와 버전 정보 프로퍼티 외에도 몇 가지 프로퍼티와 메서드가 더 존재한다. 표준 프로퍼티 뿐만 아니라 비표준이지만 널리 구현된 프로퍼티들도 있다.
   - onLine
     - navigator.onLine 프로퍼티에는(존재한다면) 브라우저의 네트워크 접속 여부에 대한 정보가 존재한다. 오프라인 상태인 동안 애플리케이션은 현재 정보를 로컬 영역에 저장하도록 할 수 있다.(20장에서 살펴볼 기술을 사용한다).
   - geolocation
     - Geolocation 객체는 사용자의 지리적 위치 정보를 확인하는 API를 정의한다. 22.1절에서 자세히 알아본다.
   - javaEnabled()
     - 브라우저가 자바 애플릿을 실행할 수 있는 경우 true를 반환하는 비표준 메서드다.
   - cookiesEnabled()
     - 브라우저가 영구적인 쿠키를 저장할 수 있는 경우 true를 반환하는 비표준 메서드다. 쿠키가 사이트 기반으로 설정되어 있다면 정확한 값을 반환하지 않는다.

# 오류 처리

1. Window 객체의 onerror 프로퍼티는 처리되지 않은 예외가 발생했을 때 호출 스택까지의 모든 경로와 브라우저의 자바스크립트 콘솔에 출력되는 오류 메시지가 전달되는 이벤트 핸들러다. 이 속성에 함수를 할당할 경우 오류 처리 핸들러가 되어 해당 창에서 자바스크립트 에러가 발생할 때마다 호출된다.

   - 첫 번째 전달인자는 오류를 설명하는 메시지다.
   - 두 번째 전달인자는 오류가 발생하는 자바스크립트 코드의 URL을 포함한 문자열이다.
   - 세 번째는 오류가 발생한 문서의 줄 번호다.

2. onerror핸들러의 반환 값 또한 중요하다. onerror 이벤트 핸들러가 false를 반환하면 핸들러가 이미 오류를 처리해서 더이상의 다른 처리가 필요하지 않음을 브라우저에게 알린다. 그러나 파이어폭스의 오류 처리 핸들러는 오류가 처리되었음을 식별하기 위한 값으로 true를 반환해야 한다.

# 다중창과 프레임

1. 데스크탑에 있는 웹브라우저 창에서든 아마도 여러 개의 탭이 있을 것이다. **_각 탭은 브라우징 문맥상 독립적이다. 한 탭은 저마다 다른 탭과는 단절된 독립적인 Window 객체를 가진다._** 하나의 탭에서 실행되는 스크립트에서는 보통 다른 탭이 존재하는지 알 수 있는 방법이 없다. 다른 탭들의 Window 객체나 문서 내용을 조작할 수 없음은 말할 것도 없다. 탭을 사용하듯이 각 데스크탑 상의 창은 자신만의 Window 객체를 가지며, 보통 다른 것들로부터 독립적이다.
2. 그러나 모든 창이 다른 창으로부터 독립적인 것은 아니다. **_하나의 창 혹은 탭에서 스크립트를 사용해 새 창 혹은 탭을 열 수 있고 이렇게 하면 원래의 창과 다른 창 그리고 다른 창의 문서와 상호작용할 수 있다._**
3. HTML 문서는 iframe 요소를 사용해 또다른 문서를 포함 할 수 있다. iframe 요소는 자기 자신의 Window 객체를 통해 중첩된 내부 브라우징 문맥을 생성한다. 그리고 중첩된 브라우징 문맥은 독립적인 탭들처럼 서로 단절되어 있지는 않다. 하나의 프레임에서는 해당 프레임의 상위 또는 하위 프레임을 스크립트로 조작할 수 있다. 물론 그렇더라도 동일 출처 정책은 이 프레임의 문서들을 검사하여 정택을 위반할 경우 조작 할 수 없도록 보호한다.  
   Window가 클라이언트 측 자바스크립트의 전역 객체이므로 각 창과 프레임에서의 자바스크립트 실행 문맥은 서로 구별된다. 그렇지만 동일 출처 정책의 제약 하에 어떤 창 내부의 자바스크립트 코드는 다른 창에 정의된 객체와 속성, 메서드를 사용할 수 있다. 동일 출처 정책에 의해 뚜렷이 구분되는 두 창이 서로 직접 영향을 끼치지 못할 때, HTML5에서는 간접적으로 통신할 수 있는 이벤트 기반 메시지 통용 API를 제공한다. 22.3절에서 이에 관해 볼 수 있다.

### 1. 창 열고 닫기

#### 1. 창열기

1. Window 객체의 open() 메서드를 사용하면 새 웹브라우저 창(혹은 탭)을 열 수 있다.
   (보통 브라우저 설정을 따른다.) Window.open()은 지정한 URL을 새 창 혹은 현재 창에 불러오고 해당 Window 객체를 반환한다. window.open()은 네개의 선택적 인자를 취한다.
   - 1번째 인자는 새 창에 표시될 문서의 URL이다. 이 인자를 생략하거나 빈 문자열을 사용하면 about:blank라는 특별한 빈 페이지 URL이 사용된다.
   - 2번째 인자는 창의 이름을 가리키는 문자열이다. 이 이름이 이미 사용되고 있고 접근도 허용된다면 해당 창을 사용한다. 그렇지 않다면 지정한 이름을 사용하여 새로운 창을 생성한다. 이 인자가 생략되면 '\_blank'가 사용되고 이름 붙지 않은 새 창을 연다.
   - 3번째 인자는 새로 열릴 창의 크기와 기능 속성의 목록을 콤마로 구분한 문자열이다. 이 인자를 생략하면 새 창은 기본 크기에 메뉴바, 상태표시줄, 도구 바 그리고 이 외의 모든 UI구성 요소를 포함한다. 탭 기능이 있는 브라우저에서는 보통 새 탭을 생성할 때 사용횐다.
     - 다양한 보안적인 이유로 인해, 명세할 수 있는 기능은 제한적이다. 예를 들면 창을 너무 작게 만들거나 화면에 보이지 않게 띄우는 일은 보통 허용되지 않는다.
   - 4번째 인자는 두 분째 인자에 지정한 이름의 창이 존재할 경우 유용하다. 4 번째 인자는 boolean 값이며, 현재 창의 브라우징 히스토리를 명시한 URL로 교체하거나(true), 새 브라우징 히스토리를 생성한다.(false). 이 인자를 생략하면 false를 사용한 것으로 간주한다.
2. **_open() 메서드의 반환 값은 해당 URL을 가리키는 Window 객체다. 새 창을 가리키는 이 Window 객체를 자바슼립트 코드에서 사용할 수 있다._**

#### 2. 창 닫기

1.close() 메서드는 창을 닫는다. 대다수 브라우저는 해당 자바스크립트 코드가 실행되고 있는 창 내에서만 자동으로 닫기를 허용한다. 만약 다른 창을 닫으려고 시도하면, 이 요청이 실패하거나 사용자가 닫기를 허용 혹은 취소할 수 있는 대화상자를 보여준다.프레임 Window 객체의 close() 메서드가 최상위 창이나 탭을 닫으려 하면 아무 일도 일어나지 않는다. 프레임을 닫으려는 시도도 마찬가지다.

### 2. 프레임 간의 관계

1. Window 객체의 open() 메서드는 원본 창 객체를 가리키는 opner 속성을 가진 새로운 Window 객체를 반환한다.이런 식으로 두 창은 서로를 참조할 수 있고, 서로 간의 속성을 읽고 상대방의 메서드를 호출할 수도 있다. 비슷한 일이 프레임 사이에서도 가능하다. 창이나 프레임 내에서 실행되는 코드는 포함하고 있는 창 혹은 프레임이나 중첩된 자식 프레임을 다음 속성들을 사용해서 참조할 수 있다.

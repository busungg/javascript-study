# 함수
1. 함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.
2. 자바스크립트 함수는 매개변수를 가질 수 있다.
    - 매개변수는 함수 몸체 내에서 지역 변수처럼 취급된다.
    - 함수 호출 시에는 함수의 매개변수로 값이나 arguments를 제공한다.
3. 각 호출에는 전달인자 외에도 호출 컨텍스트(invocation context) 값이 포함되는데, 이는 this 키워드의 값이다.
4. 어떤 객체의 프로퍼티로 할당된 함수를 해당 객체의 메서드라 한다.
    - 어떤 함수가 객체 상에서 호출되거나 객체를 통해 호출될 때, 이 객체는 호출 컨텍스트이거나 호출된 함수에서 this 값이다.
5. 새로 생성된 객체를 초기화하는 데 쓰이는 함수를 ***생성자***라고 한다.
6. 자바스크립트에서 함수는 ***객체***이고 프로그램에 의해 처리될 수 있다.
    - 자바스크립트는 함수를 변수에 할당할 수 있고, 함수를 다름 함수로 전달할 수도 있다.
    - 함수는 개체이기 때문에, 함수에 속성을 지정할 수 있고 심지어는 함수의 메서드를 호출할 수도 있다.
7. 자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있고, 함수는 해당 함수가 정의되어 있는 유효범위에 속한 어떤 변수에도 접근할 수 있다. 이는 자바스크립트 함수가 ***클러저(closure)***이며, 따라서 자바스크립트에서도 클로저라는 중요하고 강력한 프로그래밍 기법을 구사할 수 있다.

# 함수 정의하기
1. 함수는 function 키워드에 의해 정의되며, function 키워드는 함수 정의 표현식 또는 함수 정의 구문에서 사용된다.
    - 함수 이름 식별자
        - 함수 이름은 구문 형태의 함수 정의에서는 반드시 필요하다.  
        함수 이름은 곧 어떤 변수의 이름으로 사용되고, 새로 정의된 함수 객체가 이 변수에 할당된다.
        - 표현식 형태의 함수 정의에서는 이름을 생략할 수 있다.  
        ***만약 표현식 형태로 함수를 정의할 때 함수 이름을 명시한다면, 그 이름은 함수 몸체 안에서 함수 자신을 참조한다.***
    - 쉼표로 구분된 0개 혹은 임의 개수의 식별자들과 이 식별자들을 둘러싼 한 쌍의 괄호
        - 이 식별자들은 함수의 매개변수 이름이고, ***함수 몸체 내에서 지역변수***처럼 취급된다.
    - 0개 혹은 임의 개수의 자바스크립트 구문을 포함하는 한 쌍의 중괄호
        -이 자바스크립트 구문은 함수가 호출될 때마다 실행되는 함수의 본문이다.
    - ```
        //함수 표현식은 이름을 포함할 수 있는데, 이러한 이름은 재귀 호출에 유용하게 사용된다.

        //함수 정의 표현식이 이름을 포함하면
        //이 함수의 지역 함수 범위에 해당 함수와 바인딩된 이름이 포함된다.
        //사실상 함수 이름은 이 함수 내의 지역 변수가 된다.
        //표현식 형태로 함수를 정의하는 것은 한 번만 사용되는 함수에 특히 적합하다.
        var f = function fact(x) {
            if(x<=1) {
                return 1;
            } else {
                return x*fact(x-1);
            }
        };

        //때로 함수 표현식은 정의되는 즉시 호출된다.
        var tensquared = (
            function(x) {
                return x*x;=
            }(10)
        );
        ```
### 1. 중첩 함수
1. 자바스크립트에서 함수는 다른 함수와 중첩될 수 있다.
    - ```
        //함수 정의 구문
        //이 함수를 둘러싼 스크립트나 함수의 맨 위로 끌어올려(hoisted)진다.
        //구문 방식으로 정의된 함수는 이 함수가 정의된 위치보다 앞서 나오는 코드로부터 호출될 수 있다.
        function hypotenuse(a,b) {
            function square(x) { return x * x; } 
            return Math.sqrt(square(a) + sqare(b));
        }
        ```
    - ***변수 범위 규칙***
        - 중첩된 함수는 해당 함수가 속한 함수(혹은 함수들)의 매개변수와 변수에 접근할 수 있다.
        - 앞의 코드를 보자면 안쪽 함수 square()는 바깥 함수 hypotenuse()에 정의된 매개변수 a와 b를 읽고 쓸 수 있다.
2. 함수 선언 구문
    - 전역 코드 혹은 다른 함수 내에서 사용할 수 있다.
    - 반복문 내부, 조건문, try/catch.finally 또는 with 구문 내에는 사용 할 수 없다.
        - 함수 선언 구문은 호이스팅(끌어올림)이 되기 때문이며 자바스크립트는 함수 스코프를 사용하기 때문이다.
    - 하지만 표현식 형태로 정의된 함수는 자바스크립트 코드 어디에나 사용할 수 있다.

# 함수 호출하기
1. 함수를 정의했더라도 함수 몸체의 자바스크립트 코드는 함수를 호출하지 않으면 실행되지 않는다.
2. 호출 방법
    - 일반적인 함수 형태
    - 메서드 형태 (객체의 프로퍼티에 할당된 함수)
    - 생성자
    - 해당 함수의 call()과 apply() 메서드를 통한 간접적 방식

### 1. 함수 호출
1. 함수는 일반적인 함수 형태로 호출되거나 호출 표현식과 함께 메서드 형태로 호출된다.
    - ```
        var total = distance(0,0,2,1) + distance(2,1,3,4);
        ``` 
2. 함수 호출 시 평가 순서
    1. 각 전달인자 표현식(괄호 사이에 있는 것)이 평가되고, 평가 결과 값이 해당 함수의 전달인자가 된다.
3. ECMAScript 5 일반 모드의 함수 호출에서 호출 컨텍스트(this) 값은 global 객체다. 엄격한 모드에서는 undefined다.
    - 일반적인 함수 형태로 호출하도록 작성된 함수는 보통 this 키워드를 사용하지 않는다.

### 2. 메서드 호출
1. 메서드는 ***객체의 속성***으로 저장된 자바스크립트 함수일 뿐이다.
    - 만약 함수 f와 객체 o가 있다면, 이름이 m인 메ㅐ서드를 다음과 같이 정의할 수 있다.
    - ```
        o.m = f;

        //객체 o에 저장된 메서드를 호출
        o.m();
        ```
2. 메서드 호출은 함수 호출에 비해 한 가지 중요한 분이 다른데, ***그것은 바로 호출 컨텍스트***이다. 속성 접근 표현식은 객체와 속성 이름으로 구성되어 있다. 이와 마찬가지로 메서드 호출 표현식에서 객체는 호출 컨텍스트가 되고, 함수 몸체에서는 this 키워드를 사용해서 객체를 참조할 수 있다.
    - ```
        var calculator = {
            operand1: 1,
            operand2: 2,
            add: function() {

                //이 객체를 참조하기 위해 this 키워드를 사용하였다.
                this.result = this.operand1 + this.operand2;;

            }
        };

        calculator.add(); // => 1+1을 계산하기 위해 메서드를 호출
        calculator.result // => 2
        ```
3. ***변수와 달리 this 키워드에는 범위가 없고 중첩 함수는 호출자의 this값을 상속하지 않는다.***      
만약 중첩 함수가 메서드 형태로 호출되면, 중첩 함수에서의 this 값은 그 함수가 속한 객체다.   
만약 중첩 함수가 함수 형태로 호출되면, 중첩 함수의 this 값은 global객체(일반 모드) 또는 undefined(엄격한 모드) 중 하나다.

### 3. 생성자 호출
1. 함수나 메서드 호출 앞에 new 키워드가 있다면, 그것은 생성자 호출이다.
2. 생성자 호출은 일반 함수와 메서드 호출에 비해 매개변수, 호출 컨텍스트와 반환 값을 다루는 방식이 다르다.
3. 생성자에 매개변수가 없다면, 자바스크립트 생성자 호출 문법은 전달인자 목록과 괄호를 아예 생략하는 것을 허용한다.
    - ```
        //다음 두 줄은 같다.
        var o = new Object();
        var o = new Object;
        ```
4. 생성자 호출 시
    - 생성자의 프로토타입 속성을 상속받은 새로운 빈 객체가 생성된다.
    - 생성자 함수는 객체를 초기화하고, 새로 생성된 이 객체는 ***생성자 함수의 호출 컨텍스트로 사용된다.***
    - ***생성자 함수는 새로 생성된 객체를 this 키워드로 참조할 수 있다.*** 주의할 것은 생성자 호출이 마치 메서드 호출처럼 보이는 경우라도, 메서드가 속한 객체가 아닌 새로 생성된 객체가 호출 컨텍스트로 사용된다는 점이다. 즉, new o.m()과 같은 표현식에서 o가 호출 컨텍스트로 사용되지는 않는다는 뜻이다.
    - 생성자 함수는 보통 return 키워드를 사용하지 않는다. 일반적으로 생성자 함수는 새 객체를 초기화하고, 생성자 함수 몸체 끝에 이르면 암시적으로 그 객체를 반환한다.

### 4. 간접호출
1. call()
2. apply()

# 함수 전달인자와 매개변수
### 1. 생략 가능한 매개변수
1. 본래 정의한 것보다 적은 수의 전달인자로 함수가 호출되면, 나머지 매개변수는 undefined 값으로 설정된다.

### 2. 가변길이 전달인자 목록: Arguments객체
1. 함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 진자 값을 직접적으로 참조할 방법은 없다. Arguments 객체는 이러한 문제에 대한 해결책이다.
2. 함수 몸체 내에서 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다. Arguments 객체는 유사 배열 객체이고, 이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올 수 있다.
3. ***일반 모드에서 만약 함수에 매개변수가 정의되어 있으면, Arguments 객체의 배열 요소는 해당 함수에 전달된 전달인자 값에 대한 별칭이다.*** Arguments 객체의 숫자 요소와 매개변수의 이름은 동일한 값을 가리키는 다른 두 이름이다. 전달인자의 이름을 사용하여 인자 값을 변경하면 arguments[] 배열을 통해 얻는 값도 바뀐다., 그 반대로 arguments[] 배열을 통해 얻은 인자 값을 변경하면 전달인자 이름으로 얻을 수 있는 값도 바뀐다.

# 값으로서의 함수
1. 함수의 가장 중요한 특징은 정의될 수 있고 또 호출될 수 있다는 점이다. 하지만, 자바스크립트에서 함수는 문법뿐만 아니라 값이기도 한데, 이는 함수가 변수에 할당될 수 있고 객체의 프로퍼티나 배열 요소로 저장될 수도 있으며, 다른 함수의 인자로 전달될 수도 있고, 기타 여러 방식으로 사용될 수 있음을 뜻한다.
    - ```
        //간단한 함수를 몇 개 정의한다.
        function add(x,y) {return x + y;}
        function subtract(x,y) {return x - y};
        function multiply(x,y) {return x * y};
        function divide(x,y) {return x / y};

        //위 함수 중 하나를 인자로 받아 두 개의 피연산자와 같이 호출하는 함수를 정의한다.
        function operate(operator, operand1, operand2) {
            return operator(operand1, operand2);
        }

        //(2+3) + (4*5)와 같은 값을 계산하려면 다음과 같이 함수를 호출한다.
        var i = operate(add, 
                        operate(add, 2, 3),
                        operate(multiply, 4, 5) 
                    );

        //이번에는 객체 리터럴 속에 함수 리터럴을 사용하였다.
        var operators = {
            add: function(x, y) { return x + y; },
            subtract: function(x, y) {return x - y; },
            multiply: function(x, y) {return x * y; },
            divide: function(x, y) {return x/y;},
            pow: Math.pow // 미리 정의되어 있는 함수 역시 사용할 수 있다.
        };

        //이 함수는 연산자 이름을 취하고, 객체 안에서 그 연산자를 찾고 나서
        // 주어진 피연산자와 같이 호출한다.
        // 연산자 함수를 호출하는 구문을 눈여겨보라.
        function operate2(operation, operand1, operand2) {
            if(typeof operators[operation] === 'function') {
                return operators[operation](operand1, operand2);
            }
            else throw '알 수 없는 연산자';
        }

        //(hello + ' '  + world) 같은 값을 계산하려면 다음과 같이 호출할 수 있다.
        var j = operate2('add', 'hello', operate2('add', ' ', 'world'));

        //미리 정의된 Math.pow() 함수를 사용한다.
        var k = operate2('pow', 10, 2);
        ```
# 네임스페이스로서의 함수
1. 자바스크립트 함수의 유효범위를 떠올려보자. 함수 내부에서 정의된 변수는 해당 함수가 정의된 함수 내부(중첩 함수를 포함한)에서 접근 할 수 있지만, 그 함수 바깥에는 존재할 수 없다. 함수 밖에서 정의된 변수는 ***전역 변수***이고 자바스크립트 프로그램 전체에서 접근할 수 있다.
2. 자바스크립트는 단일 코드 블록 내에서만 유효한 변수를 정의하는 방법을 제공하지 않기에, 이런 이유로 간단한 임시 네임스페이스처럼 작동하는 함수를 정의하는 기법은 ***전역 네임스페이스를 어지럽히지 않고도 변수를 정의할 수 있기에 유용하게 사용되는 방법이다.***
    - 예를 들어 어떤 자바스크립트 모듈이 있고, 이 모듈을 다수의 다른 자바스크립트 프로그램(혹은 클라이언트 측 자바스크립트일 경우 다수의 다른 웹페이지에서)에서 사용한다고 가정해보자. 대다수 코드와 마찬가지로 이 코드는 계산의 중간 결과 값을 저장하는 변수를 정의할 것이다. ***문제는 이 모듈은 여러프로그램에서 사용될 테고, 모듈의 어떤 변수가 해당 모듈을 불러오는 프로그램에서 사용하는 변수와 충돌을 일으킬지 알 수 없다는 것이다.*** 물론, 해결책은 모듈의 코드를 함수 내에 두고 그 함수를 호출하는 것이다. 이런 방식으로 변수들을 전역 변수로 취급하는 대신 그 함수의 지역 변수로 다룰 수 있다.
    - ```
        function mymodule() {
            //모듈 코드는 여기 위치한다.
            //모듈에서 사용하는 어떤 변수건 이 함수의 지역 변수다.
            //따라서 전역 네임스페이스를 어지럽히지 않는다.
        }

        mymodule(); //함수를 호출해야 하는 것을 잊지 말자!

        //이 코드는 이름이 'mymodule'인 단 하나의 전역 변수만 정의한다.

        //하나의 전역 객체의 속성을 정의하는 것도 과하다면, 단일 표현식으로 익명 함수를 정의하고 호출할 수 있다.
        (
            function() { //이름이 없는 표현식으로 mymodule 함수를 재작성.
                //모듈 코드는 여기 위치한다.
            }() //함수 리터럴을 끝내고 바로 호출함.
        );
        ```
    - ***단일 표현식으로 함수를 정의하고 호출하는 방식은 관용적으로 자주 사용되는 기법이다.***  
    앞 코드에서 중괄호 부분을 살펴보자. 함수 앞의 시작 괄호는 반드시 필요한데, 만약 시작 괄호가 없으면 자바스크립트 인터프리터는 function 키워드를 구문 형태의 함수 선언으로 간주하고 분석(parse)을 시도하기 때문이다.  
    괄호가 있으면 인터프리터는 이것을 표현식 형태의 함수 선언으로 올바르게 인식한다.     
    괄호가 꼭 필요하지 않은 상황에서도, 함수를 정의하자마자 즉시 호출하기 위해 함수 주변을 괄호로 둘러싸는건 관용적인 방식이다.

# 클로저
1. 대다수의 현대 프로그래밍 언어와 마찬가지로 자바스크립트 또한 어휘적 유효범위(lexical scoping)를 사용한다. ***이는 함수를 호춣하는 시점에서의 변수 유효범위가 아니라, 함수가 정의되었을 때의 변수 유효범위를 사용하여 함수가 실행된다는 뜻이다.***
    - 이러한 어휘적 유효범위를 구현하기 위해, 자바스크립트 함수 객체는 내부 상태에 함수 자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다.
    - ***함수 객체와 함수의 변수가 해석되는 범위(변수 바인딩의 집합)의 조합은 컴퓨터 과학 문헌에서 클로저(closure)라고 일컽는다.***
2. 자바스크립트에서 다른 유효범위 체인에서 클로저가 사용될 때가 흥미로운데, 가장 일반적인 경우는 ***어떤 함수가 그 함수 내부에서 정의한 중첩 함수를 반환하는 것이다.***
    - ```
        var scope = 'global scope'; //전역 변수
        function checkscope() {
            var scope = 'local scope'; //지역 변수
            function f() {return scope;} //이 유효범위에 있는 값을 반환한다.
            return f;
        }
        checkscope()(); // 이것은 무엇을 반환할까?
        ```
    - 이 코드에서 괄호는 checkscope() 안에서 밖으로 이동했다. 이제 checkscope()는 ***중첩 함수를 호출하고 그 결과를 반환하는 대신, 중첩 함수 객체 그 자체를 반환한다.***    
    ***중첩 함수가 정의된 위치의 외부에서 해당 중첩함수를 호출했을 때(코드에서 마지막줄에 있는 두번째 괄호), 어떤 일이 일어날까?***
        - 어휘적 유효범위의 기본적인 규칙을 기억하자
        - 자바스크립트 함수는 함수가 정의되었을 때의 유효범위 체인을 사용하여 실행한다.
        - 중첩 함수 f()가 정의된 유효범위 체인에서 변수 scope는 'local scope'로 바인드되어 있다.
        - f가 어디서 호출되든 상관없이, f가 실행될 때 이 바인딩은 항상 유효하다.
        - 따라서 코드의 제일 마지막 줄은 'local scope'를 반환한다.
3. 중첩 함수가 두 개 이상이라도 해도 같은 바깥쪽 함수에 정의되고 같은 유효범위 체인을 공유한다면, 얼마든지 공유가 가능하다.
    - ```
        function counter() {
            var n = 0;
            return {
                count: function() {return n++},
                reset: function() {n = 0;}
            };
        }

        var c = counter(), d = counter();
        c.count(); // => 0
        d.count(); // => 0: 이들은 서로 독립적이다.
        c.reset(); // reset() 메서드와 count() 메서드는 상태를 공유한다.
        c.count(); // => 0: c를 리셋했기 때문
        d.count(); // => 1: d는 리셋되지 않음
        ```
    - counter() 함수는 '카운터' 객체를 반환한다.    
    또한 ***counter()를 호출할 때마다 새로운 유효범위 체인과 새로운 내부 변수가 생성된다는 점이다.*** 따라서 counter()를 두 번 호출하면, 서로 다른 내부 변수를 가진 두 개의 counter 객체를 얻는다.
4. 이런 클로저 기법과 getter/setter 프로퍼티를 결합할 수 있다는 사실은 주목할 가치가 있다. 다음에 나오는 counter() 함수는 ***내부 상태를 다루는 데 일반 객체 프로퍼티 대신 클로저를 사용한다.***
    - ```
        function counter(n) //함수 전달인자 n은 내부 변수다.
        {
            return {
                //getter 메서드 프로퍼티는 counter 변수를 반환하고 증가시킨다.
                get count() {return n++;}
                set count(m) {
                    if(m >= n) n = m;
                    else throw Error('count error');
                }
            };
        }

        var c = counter(1000);
        c.count; //=> 1000
        c.count; //=> 1001
        c.count = 2000;
        c.count; //=> 2000;
        c.count =2000 //=> 에러!

        //counter() 함수는 지역 변수를 정의하지 않지만, 프로퍼티 접근 메서드들이 공유하는 내부 상태를 보관하기 위해 매개변수 n을 사용한다. *이로써 counter()를 호출하는 쪽에서 내부 변수의 초기값을 지정할 수 있다.*
        ```
5. ***클로저들이 공유해서는 안 되는 변수를 공유하는 실수를 발견하는 것 또한 중요하다.***
    - ```
        //이 함수는 항상 v를 반환하는 함수를 반환한다.
        function constfunc(v) {
            return function() {
                    return v;
                };
        }

        //상수 함수에 대한 배열을 생성한다.
        var funcs = [];
        for(var i = 0; i < 10; i++) {
            func[i] = constfunc(i);
        }

        //배열 요소 5의 함수는 값 5를 반환한다.
        funcs[5]() //=> 5
        ```
    - 이렇게 루프를 사용하여 여러 개의 클로저를 생성하는 코드를 사용할 때, 클로저를 정의하는 함수 내에서 루프를 이동하는 것은 흔히 볼 수 있는 실수다.
        - ```
            function constfuncs() {
                var funcs = [];
                for(var i = 0; i < 10; i++) {
                    func[i]  = function() {return i;};
                }
                return funcs;
            }

            var funcs = constfuncs();
            funcs[5]() //10 반환
            ```
        - 앞의 코드는 열 개의 클로저를 생성하고, 생성한 클로저들을 배열에 저장한다.
        - ***모든 클로저는 같은 함수 호출 내에서 정의되고, 따라서 클로저들은 변수 i에 대한 접근을 공유한다.***
        - ***constfuncs() 실행이 끝나면, 변수 i의 값은 10이고, 열 개의 클로저 모두 이 값을 공유한다.***
        - 따라서 반환된 배열에 있는 모든 함수들은 같은 값을 반환하는데, 이건 우리가 전혀 원하지 않은 값이다.
        - 중첩 함수는 유효범위에 대한 내부 사본이나 변수 바인딩과 관련한 고정된 스냅샷을 만들지 않는다.
    - ***클로저를 작성할 때 기억해야 할 또 다른사항은, this가 자바스크립트 키워드이지 변수가 아니라는 점이다. 앞서 논의한 것처럼, 모든 함수 호출에는 this 값이 있고, 바깥쪽 함수가 this 값을 별도의 변수로 저장하지 않으면 클로저는 바깥쪽 함수의 this 값에 접근 할 수 없다.***
        - ```
            var self = this; //this 값을 중첩 함수에서 사용하기 위해 변수에 따로 저장한다.
            ```
    - ***arguments 바인딩 또한 비슷하다. arguments는 키워드가 아니지만 모든 함수 호출에 자동으로 선언된다.***
        - ```
            var outerArguments = arguments; //중첩 함수에서 사용하기 위해 별도로 저장한다.
            ```
# 함수 프로퍼티, 메서드, 생성자
### 1. length 프로퍼티
1. 함수 몸체 내에서 arguments.length는 함수에 실제로 전달된 인자의 개수다. 그러나 함수 자체의 length 프로퍼티는 의미가 다르다.
2. 이 읽기 전용 프로퍼티는 함수를 정의할 때 명시한 인자 개수(arity)를 반환하는데, 이는 매개변수 목록에 정의된 매개변수의 개수이고 보통 해당 함수가 요구하는 전달인자의 개수다.

### 2. prototype
1. 모든 함수에는 prototype 프로퍼티가 있는데, 이 프로퍼티는 프로토타입 객체를 참조한다.
2. 모든 함수는 서로 다른 프로토타입 객체를 가지고 있다.
3. 함수가 생성자로 사용될 때, 새로 생성된 객체는 함수의 프로토타입 객체로부터 프로퍼티들을 상속받는다.

### 3. call()과 apply() 메서드
1. call()과 apply()는 어떤 함수를 간접적으로 호출할 수 있게 하며, 특정 함수를 다른 객체의 메서드인 것처럼 다룰 수도 있다.

### 4. bind() 메서드
1. bind()의 주요목적은 함수와 객체를 서로 묶는 것이다.
2. 함수 f의 bind() 메서드를 호출하면서 객체 o를 전달하면, bind() 메서드는 새로운 함수를 반환한다. 반환된 새 함수를(함수로) 호출하면, 원래 함수f가 o의 메서드로 호출된다.
    - ```
        function f(y) {return this.x + y}; //바인드되어야 하는 함수

        var o = {x: 1};
        var g = f.bind(o); //g(x)를 호출하면 o.f(x)가 호출된다.

        g(2); //=> 3
        ```
    - ```
        //o의 메서드로서 f를 호출하는 함수를 반환한다. 인자 또한 모두 전달된다.
        function bind(f, o) {
            if(f.bind) {
                return f.bind(o);
            } else {
                return function() {
                    return f.apply(o, arguments);
                };
            }
        }
        ```
3. ECMAScript 5의 bind() 메서드는 단지 함수를 객체에 바인딩하는 것보다 더 많은 일을 한다. bind() 메서드는 ***파셜 애플리케이션(Partial Applicaition)을 구현하는데, bind()에 전달하는 인자 중 첫 번째 이후의 모든 인자는 this 값과 함께 바인딩 된다.***
    - 파셜 애플리케이션은 함수 프로그래밍에서 일반적인 기법이고 때로는 커링(currying)이라 부르기도 한다.
    - ```
        var sum = function(x,y) { return x + y; };
        //두 인자의 합을 반환한다.
        //sum과 비슷한 새 함수를 생성하지만, this값은 null로 바인딩되고
        //첫 번째 인자는 1로 바인딩된다. 새로운 함수는 단지 하나의 인자만 요구한다.
        var succ = sum.bind(null, 1);
        succ(2); // =>3: x는 1에 바인딩되고, y인자로 2를 넘긴다.

        function f(y,z) {return this.x + y + z}; //합계를 구하는 다른 함수

        var g = f.bind({x:1}, 2); //this와 y를 바인딩한다.
        g(3); //=>6:this.x는 1에 바인딩되고, y는 2에, z는 3에 바인딩된다.
        ```
4. bind() 메서드 특징
    - 실제 bind() 메서드는 함수 객체를 length 프로퍼티와 함께 반환하는데, 이 length 프로퍼티는 바인딩된 함수에 정의되어 있는 인자 개수에서 바인딩된 인자의 수를 뺀 값이다.(0보다 작지는 않다.)
    - 함수 생성자에 대한 파셜 애플리케이션으로 사용될수 있다. 만약 bind()에 의해 반환된 함수가 생성자로 사용되면, bind()에 전달했던 this는 무시되고 원본 함수가 생성자로 호출되며, 이때 이미 바인딩된 인자들이 원본 함수 생성자에 전달된다. 
    ***bind() 메서드에 의해 반환된 함수에는 prototype 프로퍼티가 없다.(일반 함수에 있는 prototype 프로퍼티는 삭제될 수 없다.)***    
    ***그리고 이러한 바인딩된 함수를 생성자로 사용하여 생성된 객체는 원본 함수의 prototype을 상속 받는다.***    
    또한 instanceof 연산자를 바인딩된 생성자에 사용한 결과는 원본 함수에 instanceof 연산자를 사용한 경우와 같다.

### 5. toString() 메서드
### 6. Function() 생성자
1. Function() 생성자는 동적으로 자바스크립트 함수를 생성하고 실행 시간에 컴파일되는 것을 가능케 한다.
2. Function() 생성자는 생성자가 호출될 때마다 함수 몸체를 분석(parse)하고 새로운 함수 객체를 생성한다. 루프 내부 또는 자주 호출되는 함수 내에서 생성자를 호출한다면 이는 비효율적이다. 이와 반대로 ***함수 정의 표현식은 중첩 함수와 루프 내에 있더라도 매번 재컴파일 되지 않는다.***
3. ***함수 생성자가 생성하는 함수는 어휘적 유효범위를 사용하지 않는다*** 함수 생성자가 생성한 함수는 언제나 최상위 레벨 함수로 컴파일 된다.

### 7. 호출 가능한 객체 (P 253)

# 함수형 프로그래밍
1. 자바스크립트가 함수를 객체로 취급할 수 있다는 말은 자바스크립트에서도 함수형 프로그래밍 기법을 사용할 수 있다는 의미다.

### 1. 함수로 배열 처리하기
1. 숫자로 이루어진 배열이 있다고 가정하고, 이 배열에 있는 값들의 평균과 표준편차를 구한다고 하자.
    - 비 - 함수형 프로그래밍 스타일
        - ```

            ```
    - 함수형 프로그래밍 스타일
        -  ```
            var sum = function
            ```
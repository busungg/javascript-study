# 함수
1. 함수(function)는 한 번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.
2. 자바스크립트 함수는 매개변수를 가질 수 있다.
    - 매개변수는 함수 몸체 내에서 지역 변수처럼 취급된다.
    - 함수 호출 시에는 함수의 매개변수로 값이나 arguments를 제공한다.
3. 각 호출에는 전달인자 외에도 호출 컨텍스트(invocation context) 값이 포함되는데, 이는 this 키워드의 값이다.
4. 어떤 객체의 프로퍼티로 할당된 함수를 해당 객체의 메서드라 한다.
    - 어떤 함수가 객체 상에서 호출되거나 객체를 통해 호출될 때, 이 객체는 호출 컨텍스트이거나 호출된 함수에서 this 값이다.
5. 새로 생성된 객체를 초기화하는 데 쓰이는 함수를 ***생성자***라고 한다.
6. 자바스크립트에서 함수는 ***객체***이고 프로그램에 의해 처리될 수 있다.
    - 자바스크립트는 함수를 변수에 할당할 수 있고, 함수를 다름 함수로 전달할 수도 있다.
    - 함수는 개체이기 때문에, 함수에 속성을 지정할 수 있고 심지어는 함수의 메서드를 호출할 수도 있다.
7. 자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있고, 함수는 해당 함수가 정의되어 있는 유효범위에 속한 어떤 변수에도 접근할 수 있다. 이는 자바스크립트 함수가 ***클러저(closure)***이며, 따라서 자바스크립트에서도 클로저라는 중요하고 강력한 프로그래밍 기법을 구사할 수 있다.

# 함수 정의하기
1. 함수는 function 키워드에 의해 정의되며, function 키워드는 함수 정의 표현식 또는 함수 정의 구문에서 사용된다.
    - 함수 이름 식별자
        - 함수 이름은 구문 형태의 함수 정의에서는 반드시 필요하다.  
        함수 이름은 곧 어떤 변수의 이름으로 사용되고, 새로 정의된 함수 객체가 이 변수에 할당된다.
        - 표현식 형태의 함수 정의에서는 이름을 생략할 수 있다.  
        ***만약 표현식 형태로 함수를 정의할 때 함수 이름을 명시한다면, 그 이름은 함수 몸체 안에서 함수 자신을 참조한다.***
    - 쉼표로 구분된 0개 혹은 임의 개수의 식별자들과 이 식별자들을 둘러싼 한 쌍의 괄호
        - 이 식별자들은 함수의 매개변수 이름이고, ***함수 몸체 내에서 지역변수***처럼 취급된다.
    - 0개 혹은 임의 개수의 자바스크립트 구문을 포함하는 한 쌍의 중괄호
        -이 자바스크립트 구문은 함수가 호출될 때마다 실행되는 함수의 본문이다.
    - ```
        //함수 표현식은 이름을 포함할 수 있는데, 이러한 이름은 재귀 호출에 유용하게 사용된다.

        //함수 정의 표현식이 이름을 포함하면
        //이 함수의 지역 함수 범위에 해당 함수와 바인딩된 이름이 포함된다.
        //사실상 함수 이름은 이 함수 내의 지역 변수가 된다.
        //표현식 형태로 함수를 정의하는 것은 한 번만 사용되는 함수에 특히 적합하다.
        var f = function fact(x) {
            if(x<=1) {
                return 1;
            } else {
                return x*fact(x-1);
            }
        };

        //때로 함수 표현식은 정의되는 즉시 호출된다.
        var tensquared = (
            function(x) {
                return x*x;=
            }(10)
        );
        ```
### 1. 중첩 함수
1. 자바스크립트에서 함수는 다른 함수와 중첩될 수 있다.
    - ```
        //함수 정의 구문
        //이 함수를 둘러싼 스크립트나 함수의 맨 위로 끌어올려(hoisted)진다.
        //구문 방식으로 정의된 함수는 이 함수가 정의된 위치보다 앞서 나오는 코드로부터 호출될 수 있다.
        function hypotenuse(a,b) {
            function square(x) { return x * x; } 
            return Math.sqrt(square(a) + sqare(b));
        }
        ```
    - ***변수 범위 규칙***
        - 중첩된 함수는 해당 함수가 속한 함수(혹은 함수들)의 매개변수와 변수에 접근할 수 있다.
        - 앞의 코드를 보자면 안쪽 함수 square()는 바깥 함수 hypotenuse()에 정의된 매개변수 a와 b를 읽고 쓸 수 있다.
2. 함수 선언 구문
    - 전역 코드 혹은 다른 함수 내에서 사용할 수 있다.
    - 반복문 내부, 조건문, try/catch.finally 또는 with 구문 내에는 사용 할 수 없다.
        - 함수 선언 구문은 호이스팅(끌어올림)이 되기 때문이며 자바스크립트는 함수 스코프를 사용하기 때문이다.
    - 하지만 표현식 형태로 정의된 함수는 자바스크립트 코드 어디에나 사용할 수 있다.

# 함수 호출하기
1. 함수를 정의했더라도 함수 몸체의 자바스크립트 코드는 함수를 호출하지 않으면 실행되지 않는다.
2. 호출 방법
    - 일반적인 함수 형태
    - 메서드 형태 (객체의 프로퍼티에 할당된 함수)
    - 생성자
    - 해당 함수의 call()과 apply() 메서드를 통한 간접적 방식

### 1. 함수 호출
1. 함수는 일반적인 함수 형태로 호출되거나 호출 표현식과 함께 메서드 형태로 호출된다.
    - ```
        var total = distance(0,0,2,1) + distance(2,1,3,4);
        ``` 
2. 함수 호출 시 평가 순서
    1. 각 전달인자 표현식(괄호 사이에 있는 것)이 평가되고, 평가 결과 값이 해당 함수의 전달인자가 된다.
3. ECMAScript 5 일반 모드의 함수 호출에서 호출 컨텍스트(this) 값은 global 객체다. 엄격한 모드에서는 undefined다.
    - 일반적인 함수 형태로 호출하도록 작성된 함수는 보통 this 키워드를 사용하지 않는다.

### 2. 메서드 호출
1. 메서드는 ***객체의 속성***으로 저장된 자바스크립트 함수일 뿐이다.
    - 만약 함수 f와 객체 o가 있다면, 이름이 m인 메ㅐ서드를 다음과 같이 정의할 수 있다.
    - ```
        o.m = f;

        //객체 o에 저장된 메서드를 호출
        o.m();
        ```
2. 메서드 호출은 함수 호출에 비해 한 가지 중요한 분이 다른데, ***그것은 바로 호출 컨텍스트***이다. 속성 접근 표현식은 객체와 속성 이름으로 구성되어 있다. 이와 마찬가지로 메서드 호출 표현식에서 객체는 호출 컨텍스트가 되고, 함수 몸체에서는 this 키워드를 사용해서 객체를 참조할 수 있다.
    - ```
        var calculator = {
            operand1: 1,
            operand2: 2,
            add: function() {

                //이 객체를 참조하기 위해 this 키워드를 사용하였다.
                this.result = this.operand1 + this.operand2;;

            }
        };

        calculator.add(); // => 1+1을 계산하기 위해 메서드를 호출
        calculator.result // => 2
        ```
3. ***변수와 달리 this 키워드에는 범위가 없고 중첩 함수는 호출자의 this값을 상속하지 않는다.***      
만약 중첩 함수가 메서드 형태로 호출되면, 중첩 함수에서의 this 값은 그 함수가 속한 객체다.   
만약 중첩 함수가 함수 형태로 호출되면, 중첩 함수의 this 값은 global객체(일반 모드) 또는 undefined(엄격한 모드) 중 하나다.

### 3. 생성자 호출
1. 함수나 메서드 호출 앞에 new 키워드가 있다면, 그것은 생성자 호출이다.
2. 생성자 호출은 일반 함수와 메서드 호출에 비해 매개변수, 호출 컨텍스트와 반환 값을 다루는 방식이 다르다.
3. 생성자에 매개변수가 없다면, 자바스크립트 생성자 호출 문법은 전달인자 목록과 괄호를 아예 생략하는 것을 허용한다.
    - ```
        //다음 두 줄은 같다.
        var o = new Object();
        var o = new Object;
        ```
4. 생성자 호출 시
    - 생성자의 프로토타입 속성을 상속받은 새로운 빈 객체가 생성된다.
    - 생성자 함수는 객체를 초기화하고, 새로 생성된 이 객체는 ***생성자 함수의 호출 컨텍스트로 사용된다.***
    - ***생성자 함수는 새로 생성된 객체를 this 키워드로 참조할 수 있다.*** 주의할 것은 생성자 호출이 마치 메서드 호출처럼 보이는 경우라도, 메서드가 속한 객체가 아닌 새로 생성된 객체가 호출 컨텍스트로 사용된다는 점이다. 즉, new o.m()과 같은 표현식에서 o가 호출 컨텍스트로 사용되지는 않는다는 뜻이다.
    - 생성자 함수는 보통 return 키워드를 사용하지 않는다. 일반적으로 생성자 함수는 새 객체를 초기화하고, 생성자 함수 몸체 끝에 이르면 암시적으로 그 객체를 반환한다.

### 4. 간접호출
1. call()
2. apply()

# 함수 전달인자와 매개변수
### 1. 생략 가능한 매개변수
1. 본래 정의한 것보다 적은 수의 전달인자로 함수가 호출되면, 나머지 매개변수는 undefined 값으로 설정된다.

### 2. 가변길이 전달인자 목록: Arguments객체
1. 함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 진자 값을 직접적으로 참조할 방법은 없다. Arguments 객체는 이러한 문제에 대한 해결책이다.
2. 함수 몸체 내에서 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다. Arguments 객체는 유사 배열 객체이고, 이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올 수 있다.
3. ***일반 모드에서 만약 함수에 매개변수가 정의되어 있으면, Arguments 객체의 배열 요소는 해당 함수에 전달된 전달인자 값에 대한 별칭이다.*** Arguments 객체의 숫자 요소와 매개변수의 이름은 동일한 값을 가리키는 다른 두 이름이다. 전달인자의 이름을 사용하여 인자 값을 변경하면 arguments[] 배열을 통해 얻는 값도 바뀐다., 그 반대로 arguments[] 배열을 통해 얻은 인자 값을 변경하면 전달인자 이름으로 얻을 수 있는 값도 바뀐다.

# 값으로서의 함수
1. 함수의 가장 중요한 특징은 정의될 수 있고 또 호출될 수 있다는 점이다. 하지만, 자바스크립트에서 함수는 문법뿐만 아니라 값이기도 한데, 이는 함수가 변수에 할당될 수 있고 객체의 프로퍼티나 배열 요소로 저장될 수도 있으며, 다른 함수의 인자로 전달될 수도 있고, 기타 여러 방식으로 사용될 수 있음을 뜻한다.
    - ```
        //간단한 함수를 몇 개 정의한다.
        function add(x,y) {return x + y;}
        function subtract(x,y) {return x - y};
        function multiply(x,y) {return x * y};
        function divide(x,y) {return x / y};

        //위 함수 중 하나를 인자로 받아 두 개의 피연산자와 같이 호출하는 함수를 정의한다.
        function operate(operator, operand1, operand2) {
            return operator(operand1, operand2);
        }

        //(2+3) + (4*5)와 같은 값을 계산하려면 다음과 같이 함수를 호출한다.
        var i = operate(add, 
                        operate(add, 2, 3),
                        operate(multiply, 4, 5) 
                    );

        //이번에는 객체 리터럴 속에 함수 리터럴을 사용하였다.
        var operators = {
            add: function(x, y) { return x + y; },
            subtract: function(x, y) {return x - y; },
            multiply: function(x, y) {return x * y; },
            divide: function(x, y) {return x/y;},
            pow: Math.pow // 미리 정의되어 있는 함수 역시 사용할 수 있다.
        };

        //이 함수는 연산자 이름을 취하고, 객체 안에서 그 연산자를 찾고 나서
        // 주어진 피연산자와 같이 호출한다.
        // 연산자 함수를 호출하는 구문을 눈여겨보라.
        function operate2(operation, operand1, operand2) {
            if(typeof operators[operation] === 'function') {
                return operators[operation](operand1, operand2);
            }
            else throw '알 수 없는 연산자';
        }

        //(hello + ' '  + world) 같은 값을 계산하려면 다음과 같이 호출할 수 있다.
        var j = operate2('add', 'hello', operate2('add', ' ', 'world'));

        //미리 정의된 Math.pow() 함수를 사용한다.
        var k = operate2('pow', 10, 2);
        ```
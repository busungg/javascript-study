# 웹브라우저의 자바스크립트

# 자바스크립트 프로그램의 실행

1. 클라이언트 측 자바스크립트에 '프로그램'에 대한 공식적인 정의는 없다.
   하나의 웹 페이지 않에 있는 모든 자바스크립트 코드가 하나의 자바스크립트 프로그램을 구성하는데, 내장 스크립트, HTML 이벤트 핸들러,
   Javascript: URL과 \<script> 태그의 src 속성으로 참조되는 외부 자스크립트 코드가 모두 여기에 해당한다.
2. 이처럼 다른 형태로 페이지에 존재하는 독립된 코드들은 **_하나의 전역 Window 객체를 공유한다._**  
   **_이 말은 같은 Document 객체를 바라보며 같은 전역 함수와 변수를 공유한다는 뜻이고, 새로운 전역 변수가 함수가 정의되면 정의된 후에 작동하는 자바스크립트 코드에서도 이 변수와 함수가 노출된다는 의미다._**
3. 어떤 웹페이지에 (iframe 요소를 사용한) 내장된 프레임이 있으면, 내장된 문서의 자바스크립트 코드에는 문서를 내장한 페이지의 자바스크립트 코드와는 전혀 다른 전역 객체가 존재한다. 이것을 별도의 자바스크립트 프로그램으로 여길 수 있지만, 자바스크립트 프로그램의 경계에 대한 공식 정의는 없음을 기억해야 한다.
   - 컨테이너 역할의 문서와 거기에 포함된 문서가 동일 서버에 있다면, 한 문서의 코드는 다른 문서의 코드와 상호작용이 가능하고, 이것을 한 프로그램에서 작동하는 두 개의 상호작용 영역으로 여길 수도 있다. 전역 Window 객체, 그리고 창과 프레임을 분리하는 프로그램 사이의 상호작용은 14.8.3절에서 상세히 설명한다.
4. **_자바스크립트 프로그램은 두 단계로 나뉘어서 실행된다._**
   - 첫 단계에서는 문서 내용을 불러오고 script 요소의 코드를 실행한다. 물론 내장 스크립트와 외부 스크립트 모두 포함된다.
     - 스크립트는 일반적으로 문서에서 표시된 순서대로 실행된다.
     - 단일 스크립트로 따로 떼어 낼 수 있는 자바스크립트 코드는 위에서 아래로 실행되며, 이는 당연히 조건문과 반복문, 다른 제어문의 하름을 따라서 진행된다.
   - 문서를 불러온 후 모든 스크립트를 실행하면, 자바스크립트 실행은 두 번째 단계로 넘어간다. **_두 번째 단계에서는 이벤트를 중심으로 비동기적으로 자바스크립트가 실행된다._**
     - 이벤트가 주도하는 이 단계에서는, 브라우저가 비동기로 발생하는 이벤트의 응답으로 이벤트 핸들러 함수를 호출한다.
     - 여기서 호출하는 함수는 HTML 이벤트 핸들러 속성이나 첫 단계에서 실행되는 스크립트 또는 바로 전에 실행된 이벤트 핸들러에서 정의한다.
5. 코어 스크립트와 클라이언트 측 자바스크립트 모두 단일 스레드 실행 모델이다. 스크립트 코드와 이벤트 핸들러는 동시성은 없지만 한 번에 실행된다.

### 1. 동기, 비동기, 연기된 스크립트

1. HTML 파서는 script 요소를 만나면, 기본적으로 문서 파싱과 렌더링을 계속 진행하기 전에 스크립트를 먼저 실행한다.
   그래서 내장 스크립트일 때는 별 문제가 없지만, 스크립트 소스가 src 속성에 지정된 외부 파일이면, 스크립트를 모두 다운로드해서 실행할 때까지 스크립트 아래쪽의 문서 내용은 브라우저에 보이지 않는다.
2. script 태그에는 defer와 async 속성이 있는데, 이 속성을 지원하는 브러우저에서는 스크립트를 이와 다르게 실행할 수 있다.
   - defer와 async 속성은 값이 없는 불리언 속성이므로 script 태그 안에 있기만 하면 된다.
   - ```
     <script defer src=""></script>
     <script async src=""></script>
     ```
   - defer 속성을 사용하면 브러우저는 문서를 모두 불러오고 파싱해서 조작할 준비가 끝날 때까지 스크립트 실행을 미룬다.
   - async 속성을 사용하면 스크립트를 다운로드하는 동안에도 문서 파싱을 계속하고, 문서 파싱 완료와 관계없이 가급적 빨리 스크립트를 실행한다.
   - 두 속성을 모두 사용하면, 브러우저는 defer 속성은 무시하고 async 속성을 적용한다.

### 2. 이벤트가 주도하는 자바스크립트

1. 이벤트 타깃이 문서 요소일 때는 이벤트가 **_버블링(bubbling)_** 과정을 통해 문서 계층 구조를 따라 올라간다.
   - 버튼에 등록된 함수가 이벤트 전파를 멈추도록 click 이벤트를 제어하고 있지 않다면, 이벤트는 버튼 요소를 포함하고 있는 요소가 무엇이든 타고 올라간다. 그리고 상위 요소에도 click 이벤트 핸들러를 적용할 것이다.
2. 하나의 이벤트에 여러 개의 이벤트 핸들러 함수를 등록하거나, 이미 어떤 모듈이 이벤트 핸들러를 등록한 객체를 타깃을 삼아서 같은 이벤트에 이벤트 핸들러를 등록하는 모듈이 문제가 없으려면, addEventListener()이라는 이벤트 리스너 등록 메서드를 사용한다.

### 3. 클라이언트 측 자바스크립트 스레드 모델

1. 단일 스레드 실행은 코드를 매우 단순하게 만든다. 두개의 이벤트 핸들러가 절대로 동시에 실행되지 않는다는 확신 속에 코드를 짤 수 있다.
   지금 수정하려는 문서를 다른 스레드가 동시에 수정하려고 할 수 없음을 확신할 수 있고, 코드를 짤 때 멀티스레드처럼 락(lock), 데드락(deadlock),
   경합상태(race condition)도 걱정할 필요가 없다.
   **_하지만 단일 스레드 실행은 스크립트와 이벤트 핸들러가 실행되는 동안 사용자 입력에 대한 응답이 중단돼야 한다는 뜻이다._**
   이것은 자바스크립트 프로그래머에겐 부담인데, 스크립트와 이벤트 핸들러가 너무 오래 실행되면 안 되기 때문이다.
   스크립트가 오래 걸리는 작업을 실행하면, 문서 불러오기에 지연이 발생하고, 스크립트가 끝날 때까지 사용자는 문서 내용을 보지 못한다.
   이벤트 핸들러가 오래 걸리는 작업을 실행하면, 무응답 상태가 되어서 사용자가 기능이 죽었다고 생각하는 원인이 된다.
2. HTML5는 '웹 워커'라고 하는 관리 가능한 동시성 처리 방식을 제공한다. 웹 워커는 사용자 인터페이스를 멈추지 않고 오래 걸리는 연산을 실행할 수 있는 백그라운드 스레드다.
   웹 워커 스레드에서 실행하는 소스는 문서 내용에 접근 권한이 없고, 메인 스레드나 다른 웹워커와 상태 값 공유를 할 수도 없으며, 오직 비동기 이벤트로만 통신이 가능하다.
   웹 워커는 자바스크립트의 기본이 되는 단일 스레드 실행 모델을 변경하지 않는다.

### 4. 클라이언트 측 자바스크립트 실행 순서

1. 웹브라우저는 Document 객체를 생성하고 웹 페이지 분석을 시작하는데,  
   HTML 요소와 그 안의 텍스트 내용을 분석해서 Element 객체와 Text 노드를 웹 페이지 문서에 추가한다. 이때, document.readyState 속성 값은 'loading' 이다.
2. HTML 분석기가 async나 defer 속성이 없는 \<script> 요소와 만나면, 문서안에 추가시키고, 내장 스크립트건 외부 파일이건 구분 없이 실행한다.  
   이런 스크립트는 동기 모드로 실행된다. 그래서 스크립트를 다운로드(가능하다면)하고 실행하는 동안 HTML 분석기는 멈춘다. 이런 스크립트에서는 입력 대기열에 텍스트를 넣기 위해 document.write()를 사용할 수 있다.  
   이 텍스트는 HTML 분석기가 다시 작동할 때 문서의 일부가 된다. 때로는 동기 모드 스크립트에서도 단순히 나중에 사용할 함수를 정의만 하고 이벤트 핸들러만 등록한다. 하지만 이 함수를 실행할 때는 존재하는 문서 트리를 넘나들어 수정할 수 있다. 즉, 동시 모드 스크립트는 \<script> 요소 자신과 그 이전에 나온 문서 내용에 접근할 수 있다.
3. HTML 분석기가 async 속성이 지정된 \<script> 요소를 만나면, 스크립트 텍스트 다운로드를 시작하고문서 분석도 계속한다. 스크립트는 다운로드된 후에 가능한 빨리 실행되겠지만, 분석기는 멈추거나 다운로드를 기다리지 않는다.  
   비동기 스크립트에서는 document.write() 메서드를 사용할 수 없다. \<script>요소 자신과 그 이전에 나온 문서 내용에 접근할 수 있고, 추가되는 문서 내용에는 접근 권한이 있을 수도, 없을 수도 있다.
4. 문서 분석이 완료되면, document.readyState 속성 값은 'interactive'로 바뀐다.
5. defer 속성이 있는 스크립트는 문서 내에 나타나는 순서대로 실행된다. 이때도 async 속성의 스크립트는 실행될 것이다. 지연된 스크립트는 완성된 문서트리에 접근 권한이 있으며 document.write() 메서드는 사용하면 안된다.
6. 브라우저는 Document 객체에서 DOMContentLoaded 이벤트를 일으킨다. 이 이벤트는 프로그램 실행 단계가 동기 모드 스크립트 단계에서 비동기 모드인 이벤트 주도 단계로 옮겨갔다는 신호다. 그러나 이 시점까지도 아직 실행되지 않은 비동기 스크립트가 있을 수 있다.
7. 브라우저는 이 시점에서 문서를 완전히 분석했지만, 이미지 등의 추가로 불러와야 하는 내용을 기다릴 수 있다. 이런 내용도 모두 불러오고 모든 비동기 스크립트도 불러와서 실행했으면, document.readyState 속성 값은 'complete'로 바뀐다.  
   그리고 웹 브라우저는 Window 객체에 load 이벤트를 발생시킨다.
8. 이 시점부터 이벤트 핸들러는 사용자 입력 이벤트, 네트워크 이벤트, 타이머 만료 등의 응답으로 비동기 호출된다.

# 호환성과 상호운용성

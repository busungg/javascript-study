# 웹브라우저의 자바스크립트

# 자바스크립트 프로그램의 실행

1. 클라이언트 측 자바스크립트에 '프로그램'에 대한 공식적인 정의는 없다.
   하나의 웹 페이지 않에 있는 모든 자바스크립트 코드가 하나의 자바스크립트 프로그램을 구성하는데, 내장 스크립트, HTML 이벤트 핸들러,
   Javascript: URL과 \<script> 태그의 src 속성으로 참조되는 외부 자스크립트 코드가 모두 여기에 해당한다.
2. 이처럼 다른 형태로 페이지에 존재하는 독립된 코드들은 **_하나의 전역 Window 객체를 공유한다._**  
   **_이 말은 같은 Document 객체를 바라보며 같은 전역 함수와 변수를 공유한다는 뜻이고, 새로운 전역 변수가 함수가 정의되면 정의된 후에 작동하는 자바스크립트 코드에서도 이 변수와 함수가 노출된다는 의미다._**
3. 어떤 웹페이지에 (iframe 요소를 사용한) 내장된 프레임이 있으면, 내장된 문서의 자바스크립트 코드에는 문서를 내장한 페이지의 자바스크립트 코드와는 전혀 다른 전역 객체가 존재한다. 이것을 별도의 자바스크립트 프로그램으로 여길 수 있지만, 자바스크립트 프로그램의 경계에 대한 공식 정의는 없음을 기억해야 한다.
   - 컨테이너 역할의 문서와 거기에 포함된 문서가 동일 서버에 있다면, 한 문서의 코드는 다른 문서의 코드와 상호작용이 가능하고, 이것을 한 프로그램에서 작동하는 두 개의 상호작용 영역으로 여길 수도 있다. 전역 Window 객체, 그리고 창과 프레임을 분리하는 프로그램 사이의 상호작용은 14.8.3절에서 상세히 설명한다.
4. **_자바스크립트 프로그램은 두 단계로 나뉘어서 실행된다._**
   - 첫 단계에서는 문서 내용을 불러오고 script 요소의 코드를 실행한다. 물론 내장 스크립트와 외부 스크립트 모두 포함된다.
     - 스크립트는 일반적으로 문서에서 표시된 순서대로 실행된다.
     - 단일 스크립트로 따로 떼어 낼 수 있는 자바스크립트 코드는 위에서 아래로 실행되며, 이는 당연히 조건문과 반복문, 다른 제어문의 하름을 따라서 진행된다.
   - 문서를 불러온 후 모든 스크립트를 실행하면, 자바스크립트 실행은 두 번째 단계로 넘어간다. **_두 번째 단계에서는 이벤트를 중심으로 비동기적으로 자바스크립트가 실행된다._**
     - 이벤트가 주도하는 이 단계에서는, 브라우저가 비동기로 발생하는 이벤트의 응답으로 이벤트 핸들러 함수를 호출한다.
     - 여기서 호출하는 함수는 HTML 이벤트 핸들러 속성이나 첫 단계에서 실행되는 스크립트 또는 바로 전에 실행된 이벤트 핸들러에서 정의한다.
5. 코어 스크립트와 클라이언트 측 자바스크립트 모두 단일 스레드 실행 모델이다. 스크립트 코드와 이벤트 핸들러는 동시성은 없지만 한 번에 실행된다.

### 1. 동기, 비동기, 연기된 스크립트

1. HTML 파서는 script 요소를 만나면, 기본적으로 문서 파싱과 렌더링을 계속 진행하기 전에 스크립트를 먼저 실행한다.
   그래서 내장 스크립트일 때는 별 문제가 없지만, 스크립트 소스가 src 속성에 지정된 외부 파일이면, 스크립트를 모두 다운로드해서 실행할 때까지 스크립트 아래쪽의 문서 내용은 브라우저에 보이지 않는다.
2. script 태그에는 defer와 async 속성이 있는데, 이 속성을 지원하는 브러우저에서는 스크립트를 이와 다르게 실행할 수 있다.
   - defer와 async 속성은 값이 없는 불리언 속성이므로 script 태그 안에 있기만 하면 된다.
   - ```
     <script defer src=""></script>
     <script async src=""></script>
     ```
   - defer 속성을 사용하면 브러우저는 문서를 모두 불러오고 파싱해서 조작할 준비가 끝날 때까지 스크립트 실행을 미룬다.
   - async 속성을 사용하면 스크립트를 다운로드하는 동안에도 문서 파싱을 계속하고, 문서 파싱 완료와 관계없이 가급적 빨리 스크립트를 실행한다.
   - 두 속성을 모두 사용하면, 브러우저는 defer 속성은 무시하고 async 속성을 적용한다.

### 2. 이벤트가 주도하는 자바스크립트

1. 이벤트 타깃이 문서 요소일 때는 이벤트가 **_버블링(bubbling)_** 과정을 통해 문서 계층 구조를 따라 올라간다.
   - 버튼에 등록된 함수가 이벤트 전파를 멈추도록 click 이벤트를 제어하고 있지 않다면, 이벤트는 버튼 요소를 포함하고 있는 요소가 무엇이든 타고 올라간다. 그리고 상위 요소에도 click 이벤트 핸들러를 적용할 것이다.
2. 하나의 이벤트에 여러 개의 이벤트 핸들러 함수를 등록하거나, 이미 어떤 모듈이 이벤트 핸들러를 등록한 객체를 타깃을 삼아서 같은 이벤트에 이벤트 핸들러를 등록하는 모듈이 문제가 없으려면, addEventListener()이라는 이벤트 리스너 등록 메서드를 사용한다.

### 3. 클라이언트 측 자바스크립트 스레드 모델

1. 단일 스레드 실행은 코드를 매우 단순하게 만든다. 두개의 이벤트 핸들러가 절대로 동시에 실행되지 않는다는 확신 속에 코드를 짤 수 있다.
   지금 수정하려는 문서를 다른 스레드가 동시에 수정하려고 할 수 없음을 확신할 수 있고, 코드를 짤 때 멀티스레드처럼 락(lock), 데드락(deadlock),
   경합상태(race condition)도 걱정할 필요가 없다.
   **_하지만 단일 스레드 실행은 스크립트와 이벤트 핸들러가 실행되는 동안 사용자 입력에 대한 응답이 중단돼야 한다는 뜻이다._**
   이것은 자바스크립트 프로그래머에겐 부담인데, 스크립트와 이벤트 핸들러가 너무 오래 실행되면 안 되기 때문이다.
   스크립트가 오래 걸리는 작업을 실행하면, 문서 불러오기에 지연이 발생하고, 스크립트가 끝날 때까지 사용자는 문서 내용을 보지 못한다.
   이벤트 핸들러가 오래 걸리는 작업을 실행하면, 무응답 상태가 되어서 사용자가 기능이 죽었다고 생각하는 원인이 된다.
2. HTML5는 '웹 워커'라고 하는 관리 가능한 동시성 처리 방식을 제공한다. 웹 워커는 사용자 인터페이스를 멈추지 않고 오래 걸리는 연산을 실행할 수 있는 백그라운드 스레드다.
   웹 워커 스레드에서 실행하는 소스는 문서 내용에 접근 권한이 없고, 메인 스레드나 다른 웹워커와 상태 값 공유를 할 수도 없으며, 오직 비동기 이벤트로만 통신이 가능하다.
   웹 워커는 자바스크립트의 기본이 되는 단일 스레드 실행 모델을 변경하지 않는다.

### 4. 클라이언트 측 자바스크립트 실행 순서

1. 웹브라우저는 Document 객체를 생성하고 웹 페이지 분석을 시작하는데,  
   HTML 요소와 그 안의 텍스트 내용을 분석해서 Element 객체와 Text 노드를 웹 페이지 문서에 추가한다. 이때, document.readyState 속성 값은 'loading' 이다.
2. HTML 분석기가 async나 defer 속성이 없는 \<script> 요소와 만나면, 문서안에 추가시키고, 내장 스크립트건 외부 파일이건 구분 없이 실행한다.  
   이런 스크립트는 동기 모드로 실행된다. 그래서 스크립트를 다운로드(가능하다면)하고 실행하는 동안 HTML 분석기는 멈춘다. 이런 스크립트에서는 입력 대기열에 텍스트를 넣기 위해 document.write()를 사용할 수 있다.  
   이 텍스트는 HTML 분석기가 다시 작동할 때 문서의 일부가 된다. 때로는 동기 모드 스크립트에서도 단순히 나중에 사용할 함수를 정의만 하고 이벤트 핸들러만 등록한다. 하지만 이 함수를 실행할 때는 존재하는 문서 트리를 넘나들어 수정할 수 있다. 즉, 동시 모드 스크립트는 \<script> 요소 자신과 그 이전에 나온 문서 내용에 접근할 수 있다.
3. HTML 분석기가 async 속성이 지정된 \<script> 요소를 만나면, 스크립트 텍스트 다운로드를 시작하고문서 분석도 계속한다. 스크립트는 다운로드된 후에 가능한 빨리 실행되겠지만, 분석기는 멈추거나 다운로드를 기다리지 않는다.  
   비동기 스크립트에서는 document.write() 메서드를 사용할 수 없다. \<script>요소 자신과 그 이전에 나온 문서 내용에 접근할 수 있고, 추가되는 문서 내용에는 접근 권한이 있을 수도, 없을 수도 있다.
4. 문서 분석이 완료되면, document.readyState 속성 값은 'interactive'로 바뀐다.
5. defer 속성이 있는 스크립트는 문서 내에 나타나는 순서대로 실행된다. 이때도 async 속성의 스크립트는 실행될 것이다. 지연된 스크립트는 완성된 문서트리에 접근 권한이 있으며 document.write() 메서드는 사용하면 안된다.
6. 브라우저는 Document 객체에서 DOMContentLoaded 이벤트를 일으킨다. 이 이벤트는 프로그램 실행 단계가 동기 모드 스크립트 단계에서 비동기 모드인 이벤트 주도 단계로 옮겨갔다는 신호다. 그러나 이 시점까지도 아직 실행되지 않은 비동기 스크립트가 있을 수 있다.
7. 브라우저는 이 시점에서 문서를 완전히 분석했지만, 이미지 등의 추가로 불러와야 하는 내용을 기다릴 수 있다. 이런 내용도 모두 불러오고 모든 비동기 스크립트도 불러와서 실행했으면, document.readyState 속성 값은 'complete'로 바뀐다.  
   그리고 웹 브라우저는 Window 객체에 load 이벤트를 발생시킨다.
8. 이 시점부터 이벤트 핸들러는 사용자 입력 이벤트, 네트워크 이벤트, 타이머 만료 등의 응답으로 비동기 호출된다.

# 호환성과 상호운용성

1. 웹브라우저는 웹 앱을 위한 운영체제다. 하지만 웹은 통일되지 않은 이질적인 환경이다.  
    여러분의 웹 문서와 애플리케이션은 각기 다른 운영체제(윈도우, 맥OS, 리눅스, iOS, 안드로이드)에서 여러 벤더(마이크로소프트, 모질라, 애플, 구글, 오페라)의 여러 버전 브라우저에서 보이고 실행될 것이다. 광범위한 다양성을 가진 각각의 플랫폼에서 정상적으로 작동해야 하기 때문에, 이런 클라이언트 측 자바스크립트 프로그램을 작성하는 일은 거대한 도전이다.  
    클라이언트 측 자바스크립트 호환성과 상호운용성 문제점은 일반적으로 세가지로 분류한다.

   - 기술의 진화
   - 미구현 기능
     - 어떤 업체는 구현하고 어떤 업체는 하지 않는다.
   - 버그
     - 모든 브라우저는 버그가 있다.

### 1. 호환성 라이브러리

1. 비호환성 문제를 다루는 가장 쉬운 방법은 이 문제를 피해 갈 수 있는 라이브러리를 사용하는 것이다.
   - 현실적으로, 웹 개발자들은 모든 웹 페이지에 jQuery 같은 클라이언트 측 자바스크립트 프레임워크를 사용한다. 이런 프레임워크를 필수요소로 만드는 이유 중 하나는 새로운 클라이언트 측 API를 정의하면서 모든 브라우저에서 호환되도록 구현했기 때문이다.

### 2. 기능 테스트

1. 기능 테스트(호환성 테스트)는 비호환성 문제에 대처하기 위한 강력한 기법이다.  
   어떤 기능을 사용하려 하는데 모든 브라우저에서 지원하지는지 확실하지 않다면,
   기능 지원 여부를 확인하기 위한 테스트 코드를 포함시켜야 한다.

   - ```
        if(element.addEventListener) {
            element.addEventListener('keydown', handler, false);
        } else if(element.attachEvent) { //사용 전에 IE 메서드를 테스트
            element.attachEvent('onkeydown', handler);
        }
     ```

# 접근성

1. 시각 장애나 신체적 장애가 있는 방문자가 정보에 접근하는 코드를 만들기 위해 WAI-ARIA 표준에 익숙해져야 한다.

# 보안

1. 웹브라우저에 자바스크립트 인터프리터가 들어 있다는 말은 웹 페이지를 불러오는 순간
   여러분의 컴퓨터에서 임의의 자바스크립트 코드가 실행될 수도 있다는 의미다.
   이것은 분명 보안상 문제가 될 수 있기 때문에 브라우저 제조사는 다음 두 가지 상반된 목표의 균형을 잡기 위해 노력해 왔다.
   - 웹 에플리케이션에서 사용할 수 있는 강력한 클라이언트 측 API를 정의하는 일
   - 사용자 데이터에 접근해서 변경하고, 개인정보를 손상시키거나 금융사기를 저지르고, 여러분이 시간을 낭비하게 하는 악의적인 코드를 예방하는 일

### 1. 동일 출처 정책 ([same-origin policy](https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy))

1.  동일 출처 정책은 자바스크립트 코드가 웹 콘텐츠와 상호작용을 할 수 있다는 사실 전반에 걸친 폭넓은 보안 제약 사항이다.
    이 정책은 일반적으로 iframe 요소를 포함한 웹 페이지나 새로운 브라우저 창이 열릴 때 작동하는데, 한 창이나 프레임의 코드는 동일 출처 정책의 감독하에 다른 창이나 프레임과 상호작용한다.
2.  자바스크립트는 스크립트를 포함하고 있는 문서와 같은 출처의 문서에 있는 window와 Docuemnt객체의 속성만을 사용 할 수 있다.
3.  **_문서의 출처는 불러온 URL의 프로토콜과 호스트, 포트로 정의한다._** 다른 여러 서버에서 불러온 문서는 출처가 다르다. 같은 호스트에 포트만 다른 서버에서 불러온 문서도 출처는 다르다. 또한 http: 프로토콜을 사용해서 불러온 문서는, 설사 같은 웹 서버에서 가져왔다 하더라도 https: 프로토콜을 사용해서 불러온 문서와 출처가 다르다.
    - 그러나 스크립트 파일의 출처는 동일 출처 정책과 전혀 관계가 없다. 중요한 것은 스크립트를 포함하고 있는 문서의 출처다.
    - 예를 들어서 호스트 A의 스크립트가 script 요소의 src 속성으로 호스트 B의 웹페이지에 포함되어 있다고 해보자. **_ 여기서 스크립트의 출처는 호스트 A가 아니라 호스트 B가 된다. 따라서 스크립트를 포함한 문서의 콘텐츠 전체에 접근할 수 있다._**
    - 이제 스크립트가 호스트 B에 있는 두 번째 문서를 새 창으로 열면, 두 번째 문선의 콘텐츠도 모두 접근할 수 있다.
    - 하지만 스크립트가 호스트 C에 있는 문서 혹은 스크립트와 같은 호스트 A에 있는 문서를 세 번째 창으로 연다면, 동일 출처 정책의 영향을 받아서 스크립트는 세 번째 문서에 접근할 수 없다.
4.  동일 출처 정책은 대부분 적용되며, 특히 Document 객체의 속성은 모두 적용된다. 다른 서버에서 불러온 문서를 포함하는 창은 사실상 여러분의 스크립트가 출입할 수 없는 영역이라고 생각해야만 한다.
5.  동일 출처 정책은 XMLHttpRequest 객체로 HTTP를 스크립트에서 직접 제어할 때에도 적용된다. 이 객체는 문서를 불러온 서버에서는 HTTP 요청을 얼마든지 허용하지만, 출처가 다른 웹 서버와의 통신은 허락하지 않는다.
6.  동일 출처 정책은 저작권있는 정보를 스크립트로 훔쳐가는 것을 방지하기 위해도 필요하다. 어떤 회사의 인트라넷 내에서 실행 중인 브라우저가 방화벽 바깥에서 악성 코드를 불러왔다고 해보자. 동일 출처 정책과 같은 제약이 없다면, 이 스크립트는 빈 창을 열고 인트라넷 상의 파일 탐색 창처럼 사용자를 속이려 할 수도 있다. 이런 악성 코드는 인트라넷 창의 콘텐츠를 읽어온 후, 악성 코드를 사용한 공격자의 서버에 정보를 전송한다. 동일 출처 정책은 이런 종류의 악의적인 작동을 방지한다.

### 2. 동일 출처 정책 해제

1. 하위 도메인을 여러 개 사용하는 대형 사이트에서는 동일 출처 정책이 문제를 일으킨다. 예를 들어서 home.example.com 문서의 스크립트가 developer.example.com에서 불러온 문서의 속성을 읽으려고 하거나, orders.example.com의 스크립트가 catalog.example.com에 있는 문서의 속성을 필요로 할지도 모른다.
   - Document 객체의 domain 프로퍼티를 사용하면 이런 종류의 멀티 도메인 사이트 문제를 해결할 수 있다. 프로퍼티의 기본 값은 문서를 불러온 서버의 호스트 이름이다. 이 속성 값을 변경할 수는 있지만, 기본 값의 도메인에서 뒷부분의 문자열을 규칙에 맞게 사용할 때만 가능하다. 따라서 domain 속성의 값이 원래 homke.example.com이라면 example.com은 지정할 수 있지만 home.example은 사용 할 수 없다. 뿐만 아니라, domain 속성의 값은 최소한 마침표(.) 하나는 있어야 하므로 com이나 혹은 다른 일차 도메인들도 사용할 수 없다.
     - 두 개의 창이나 프레임에서 domain 속성이 같은 값으로 지정된 스크립트를 가지고 있다면, 두 창에서는 동일 출처 정책이 해제되고, 상호작용도 가능해 진다.
     - 예를 들면, orders.example.com과 catalog.example.com에서 불러온 문서끼리 협업한느 스크립트는 두 문서의 document.domain 속성을 example.com으로 지정하면, 출처가 같아지므로 서로의 속성을 불러 올 수 있다.
   - 출처 간 자원 공유(Cross-Origin Resource Sharing, CORS)를 사용할수도 있다.
     CORS는 Access-Control-Allow-Origin이라는 응답 헤더로 HTTP의 출처를 확장한다. 그래서 파일 요청이 들어올 명시적인 출처 목록의 헤더나 와일드카드(\*)를 서버에 사용할 수 있고, 그러면 어느 사이트에서든 요청할 수 있는 파일 제공이 가능하다. 그래서 XMLHttpRequest로 출처가 다른 HTTP 요청을 하여도 동일 출처 정책으로 금지 되지 않는다.

### 3. 크로스 사이트 스크립팅

1. 교차 사이트 스크립팅 혹은 XSS(Cross-site scripting)은 사이트 공격자가 목표 사이트에 HTML 태그나 스크립트를 집어넣는 보안 문제를 일컫는 말이다.
2. 예시로 자바스크립트를 사용하여 사용자의 이름을 보여주는 웹페이지를 보자

   - ```
        <script>
        var name = decodeURIComponent(window.location.search.substring(1)) || '';
        document.write('Hell ' + name);

        </script>
     ```

   - 스크립트 두 번째 줄을 보면 현재 URL에서 물음표(?) 이후의 부분을 가져오는 window.location.search를 사용한다. 문서에 동적으로 내용을 넣기 위해 document.write()를 사용했다.
     이는 다음과 같는 형태의 URL을 고려한 페이지이다. http://www.example.com/greet.html?David
   - 하지만 다음 URL을 호출했을 때는 무슨 일이 일어날지 생각해보자.
     http://www.example.com/greet.html?%3Cscript%3Ealert(%22David%22)%3C%2Fscript%3E  
     3Cscript%3Ealert(%22David%22)%3C%2Fscript%3E는 \<script>alert("David")\</script> 이다.  
     이 URL은 동적으로 다른 스크립트를 생성한다. 다른 예로 script 태그에 src에 siteB/evil.js가 포함되어 있다고 생각해보자 이 스크립트 evil.js는 악의적인 사이트 B에서 제공되었지만, 지금은 사이트 A에 포함되었다. 따라서 사이트 A의 콘텐츠에 무엇이든 할 수 있고 페이지 외형을 망가뜨리거나 오작동을 일으킨다. 더 우려되는 것은, 악성 코드는 사이트 A에서 만들어진(사용자 정보 혹은 계좌번호 같은) 쿠키를 읽고 이 데이터를 사이트 B에 보낼 수 있다. 스크립트는 사용자의 키보드 입력까지도 추적하여 사이트 B로 보낼수 있다.

3. XSS 공격을 막는 일반적인 방법은 동적으로 문서 내용을 생성하기 전에, HTML 태그를 지워 버리는 것이다.
   - ```
        name = name.replace(/</g, '<').replace(/>/g, '>');
     ```
   - 이 간단한 코드는 입력된 HTML 문자열에서 꺽쇠 괄호를 치환한다. 이렇게 문자열 안에 있는 모든 HTML 태그를 무시하고 비활성화 한다.

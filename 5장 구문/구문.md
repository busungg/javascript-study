# 구문
1. 프로그램(스크립트)은 컴퓨터에 의해 단계별로 수행될 명령들의 집합이다.
2. 각각의 명령을 문(statement)이라 하며 문이 실행되면 무슨 일인가가 일어나게 된다.

# 표현문
1. 자바스크립트 구문 중에서 가장 간단한 형태는 부수 표과가 있는 표현식이다.
2. 할당문이 바로 이러한 표현문의 주요 항목에 속한다.
    - ```
        greeting = 'Hello' + name;
        i *= 3;
        ```
    - ++와 --같은 증감 연산자들은 할당문과 관계가 있다. 이들은 변수 값 자체를 바꾸는 부수 효과가 있는데, 이는 마치 변수에 값을 할당한 것과 같은 효과를 보인다.
3. delete 연산자는 객체 프로퍼티를 삭제하는 중요한 부수 효과가 있다. 따라서 이 연산자는 표현식의 일부로 쓰이기 보다는 구문으로 많이 사용된다.
4. 표현문의 다른 종류로 함수 호출이 있다.
    - ```
        cx = Math.cos(x);
        ```

# 복합문과 빈 구문
1. 하나의 표현식 안에 여러 표현식을 합칠 때에는 쉼표(,) 연산자를 사용하는데 이와 같이 구문 블록은 단순히 여러 구문을 중괄호로 감싸면 된다.
    - ```
        {
            x = Math.PI;
            cx = Math.cos(x);
        }
        ```
    - 구문 블록은 세미콜론(;)으로 끝나지 않는다.
    - 자바스크립트에는 블록 단위의 유효범위(scope)가 존재하지 않기 때문에, 구문 블록 안에 선언된 변수는 블록 뿐 아니라 블록 밖에서도 접근할 수 있다.

2. 빈 구문은 하나의 구문이 있어야할 곳에 아무런 구문도 없는 것을 말한다.
    - ```
        ;

        // 자바스크립트 인터프리터는 빈 구문을 만나면 아무것도 실행하지 않는다.
        // 빈 구문은 종종 몸체가 비어있는 루프를 만들고자 할 때 유용하다.
        // 배열 a를 초기화한다.
        for(i = 0; i < a.length; a[i++] = 0) ;
        ```
    - for 루프나 while 루프 또는 if문이 끝나는 오른쪽 괄호 다음에 의도하지 않은 세미콜론(;)을 넣을 경우에 찾기 힘든 버그를 발생시킬 수 있음을 유의해야 한다.
    -   ```
        if((a == 0) || (b == 0)) ; //조건과 무관하게 아무 일도 하지 않는다.
            o = null; // 이 행은 항상 실행된다.
        ```

# 선언문
1. var와 function은 각각 변수와 함수를 선언하는 선언문이다. 이러한 선언문은 각각 변수나 함수 이름 같은 식별자를 정의한다.
2. 선언문에서 정의된 식별자는 프로그램 내에서 사용할 수 있고, 이 식별자를 통해 값을 할당할 수도 있다.

### var
1. 명시적으로 하나 또는 그 이상의 변수를 선언하는 데 사용한다.
2. 문법
    - var 변수_1 [ = 값_1 ] [ , ... , 변수_n [= 값_n]]
    - var 키워드 다음에는 선언될 변수들이 쉼표로 구분되어 이어진다.
    - 이때, 각 변수는 초기 값을 지정하기 위해 표현식을 가질 수도 있다.
    - ```
        var i; // 하나의 변수를 선언함
        var j = 0; // 하나의 var와 값을 선언함
        var p, q; //두 변수를 선언함
        var greeting = 'hello' + name; // 복잡한 초기 값 표현식
        var x = 2.34, y = Math.cos(0.75), r, theta; // 많은 변수들이 선언됨
        var x = 2, y = x*x; //두 번째 변수 y에서 첫 번째 변수 x를 사용함
        var x = 2,
            f = function(x) {return x*x}; //각 라인 별로 변수를 선언함
        ```

### function
1. function 키워드는 함수를 정의하는 데 쓰인다.
2. 함수 정의 표현식도 구문형태로 사용할 수 있다.
    - ```
        var f = function(x) {return x+1;} //변수에 함수를 할당하는 표현식
        function f(x) { return x + 1; } //변수 이름을 포함한 구문
        ```
3. 함수 선언문의 문법
    - function 함수이름([전달이자1 [, 전달인자2 [..., 전달인자n]]]) {
       구문 
    }
    - '함수이름'은 정의할 함수 이름을 식별자로 갖는다.
    - 함수 몸체에는 몸체에 하나의 구문이 오더라도 중괄호가 반드시 필요하다.
4. 함수선언문은 자바스크립트 최상위 단계 코드에서 나타나거나 다른 함수 내에 중첩될 수 있다. 하지만 다른 함수 속에 중첩되었을 때는 함수 선언이 중첩된 함수 내에서 최상위 단계에 위치하게 된다. 다시 말해, 함수 선언은 if문이나 while 루프 또는 다른 구문안에 있을 수 없다.
5. 함수 선언 구문은 함수 정의 표현식과는 차이가 있다. 함수 선언문은 함수 이름을 변수로서 선언한 후 이 변수에 함수 객체를 할당한다. var 로 선언한 변수와 같이, 함수 선언문으로 정의된 함수는 스크립트나 함수 유효범위의 최상단에 위치하게 되어 해당 유효범위 내에서 사용이 가능하다.
    - var문을 이용한 변수 선언은 유효범위의 최상단에 위치하게 되지만, 최초에 변수를 초기화한 코드는 그대로 유지된다.
    - 하지만 함수 선언문을 이용하면 함수의 이름과 본문 모두 유효범위 최상단에 위치하게 된다. 이때 스크립트나 함수 또는 함수의 중첩 함수에서 선언한 함수를 사용할 수 있다. 이는 자바스크립트 함수 선언이 끝나기 전에 호출될 수 있음을 말한다.

# 조건문 (제어문)
1. 조건문은 특정 표현식의 값에 따라 구문을 실행시키거나 건너뛴다.


### if
1. 형식
    - ```
        if(표현식)
            구문
        ```
    - ```
        if(표현식)
            구문1
        else 
            구문2
        ```
### else if
1. else if문은 엄밀히 말해 자바스크립트 고유의 구문은 아니다. 다만 if/else문을 반복해서 사용하던 것이 프로그래밍 관습으로 굳어져서 널리 쓰이게 된 것 뿐이다.
2. 형식
    - ```
        //if문을 나열하는 것, 이어지는 if문은 그 이전 구문의 else 절에 속한것 뿐이다.
        if(n == 1) {

        } 
        else if(n == 2) {

        }

        //else if문을 중첩된 형태로 풀이
        if(n == 1) {

        }
        else {
            if(n == 2) {

            }
        }
        ```

### switch
1. 대응하는 case를 판별할 때는 동등 연산자 ==가 아닌 일치 연산자 ===가 사용된다. 따라서 아무런 타입 변환 없이 표현식 값이 같아야만 한다.
2. switch문이 실행될 때마다 모든 case 표현식이 매번 평가되지는 않기 때문에, case 표현식에 함수 호출이다 값 할당과 같이 부수 효과를 일으킬 수 있는 표현식을 사용해서는 안된다. 가장 안전한 방법은 case 표현식을 상수 표현식만으로 제한하는 것이다.


# 루프
1. 루프문은 분기 경로에서 일정 부분의 코드를 실행한 후, 다시 해당 분기 경로로 되돌아간다.

### while
### do/while
1. 형식
    - ```
        do 
            구문
        while(표현식);

        //while 루프와는 달리 do 루프의 끝에는 세미콜론(;)이 붙는다.
        //그 이유는 do 루프가 그저 루프 몸체의 끝을 알리는 중괄호만으로 끝나지 않고 루프 조건을 명시하며 끝나기 때문이다.
        ```
### for
1. 형식
    - ```
        for(초기화 ; 테스트 ; 증가)
            구문

        //루프가 시작되기 전 '초기화' 표현식이 한번 평가된다.
        //'테스트' 표현식은 매회 반복이 일어나기 직전에 평가되며, 루프 몸체 실행 여부를 제어한다. 만약 '테스트' 표현식이 true이면 루프의 '구문'이 실행된다.
        //마지막으로 '증가'표현식이 실행된다.
        ```
2. 예시
    - ```
        var i, j;
        for(i = 0, j = 10; i < 10; i++, j--) {
            sum += i * j;
        }
        ```
    - ```
        //링크드리스트 루프 변수를 숫자형으로 사용하지 않아도 된다.
        function tail(o) {
            for(; o.next !== null; o = o.next) {
                //빈 구문
            }

            return o;
        }
        ```

### for/in
1. 형식
    - ```
        for(변수 in 객체)
            구문
        
        // 변수에 객체가 가진 프로퍼티 이름을 할당한다.
        ```
    - 자바스크립트 인터프리터는 먼저 객체 표현식을 평가한다. 이때 표현식이 null이나 undefined로 평가되면 인터프리터는 해당 루프를 중단하고 다음 구문을 실행한다. 만약 표현식이 원시 값으로 평가되면 해당 값은, 값과 사응ㅇ하는 Wrapper객체로 바뀐다.
    - 인터프리터는 객체 표현식을 평가한 다음에 '변수' 표현식을 평가한 후 , 객체의 각 열거 가능한 프로퍼티 이름을 '변수'에 할당한다.     
    for/in 루프에서 사용하는 '변수'는 할당 표현식의 좌변에 적합한 무언가로 평가되는 임의의 표현식을 사용할 수 있다. 이 표현식은 루프가 돌 때마다 평가되는데, 이때 매번 다르게 평가될 수 있다.   
        ```
            var o = {x:1, y:2, z:3};
            var a = [], i = 0;
            for(a[i++] in o) /*루프 몸체는 비어있다.*/

            //객체의 모든 프로퍼티 이름을 배열에 복사할 수 있다.
        ```
    - **for/in 루프는 실제로 객체가 가진 모든 프로퍼티를 열거하지 않고 오직 '열거할 수 있는 프로퍼티'만 열거한다.**     
    자바스크립트 코어에 정의된 다양한 내장 메서드들은 일반적으로 열거할 수 없다.    
    하지만 사용자가 임의로 정의한 프로퍼티와 메서드들은 모두 열거할 수 있다.    
    상속된 사용자 정의 프로퍼티 또한 for/in 루프를 통해 열거할 수 있다.
    - 프로퍼티 열거 순서는 정해지지 않았지만 주요 브라우저 벤더사들의 자바스크립트 구현체는 객체의 프로퍼티들이 정의된 순서대로 열거하고 있다. 만약 객체가 객체 리터럴로 생성되었을 경우에는 열거 순서가 리터럴에 명시한 프로퍼티 순서와 같다.

# 점프문
1. 자바스크립트 인터프리터가 점프문을 만나면 소스 내의 특정 위치로 건너뛴다.

### break
1. break문을 사용하면 break문을 감싸고 있는 가장 안쪽의 루프 혹은 switch문에서 즉시 빠져나온다.

### continue
1. continue문은 break문과 유사하다. 다만 루프를 빠져나오지 않고 새로운 반복을 시작한다는 점이 다르다. continue문은 항상 루프의 몸체 내부에서 사용해야만 한다. 이 외의 부분에 사용되면 문법 에러가 발생한다.
    - while 루프에서는 루프의 시작 부분에 지정된 '표현식'을 다시 테스트한다.    
    결과가 true이면 루프 몸체 처음부터 다시 실행을 시작한다.
    - do/while 루프에서는 일단 루프의 끝 부분까지 건너뛴다. 그리고 루프 조건을 다시 테스트하여 결과가 true이면 루프 몸체 처음부터 다시 실행을 시작한다.
    - for 루프에서는 ***'증가'표현식을 평가***한 후 , '테스트' 표현식을 테스트하여 다음 반복을 수행할지 여부를 판단한다.
    - for/in 루프에서는 다음 차례의 프로퍼티 이름을 루프 시작에서 지정된 변수에 할당한 후 루프를 다시 시작한다.

### return
1. return문은 함수 호출 표현식의 값, 즉 함수에서 반환되는 값을 지정하는 데 쓰인다.
2. 형식
    ```
        return 표현식;
    ```
3. return문은 오직 함수 몸체 내부에서만 나타날 수 있다. 다른 곳에서 사용하면 문법 에러가 발행한다. return문이 실행되면 '표현식'이 평가되어 그 결과가 함수의 값으로 반환된다.
4. 함수 내에 return문이 없다면 함수 호출은 단지 함수 몸체의 끝에 도달할 때까지 모든 구문을 차례로 실행하고, 호출한 지점으로 돌아간다. 이 경우에 해당 함수 호출 표현식의 값은 undefined가 된다.

### throw
1. '예외'란 예외적인 상황이나 에러가 발생했음을 가리키는 신호다. 예외를 '발생 시키는 것(throw)'은 그런 에러나 예외 상황을 알린다는 의미다. 
2. 형식
    ```
        throw 표현식;
        //표현식은 어떤 형식이든 그 값을 평가한다.
    ```
3. 예외가 발생하면 자바스크립트 인터프리터는 정상적인 프로그램 실행을 즉시 중단하고 가장 가까운 예외 처리기로 넘어간다. 예외 처리기는 catch절을 사용하여 작성되는다. 예외를 발생시킨 코드 블록이 catch절과 연결되어 있지 않으면, 인터프리터는 바로 상위 단계를 감싸고 있는 코드 블록에 연결된 예외 처리기가 있는지 확인한다. 이 과정은 처리기를 찾을 때까지 계속된다. 만약 해당 함수 내에서 예외를 처리할 try/catch/finally문을 찾을 수 없다면, 함수를 호출했던 블록으로 그 예외가 전파되어 올라간다. 이 같은 방법으로 호출 스택을 따라서 예외가 전파되어 올라간다. 예외 처리기를 찾을 수 없는 경우 해당 예외는 에러로 취급되고 사용자에게 보고된다.

### try / catch / finally
1. 자바스크립트의 예외 처리 기법이다. try절은 단순히 예외가 발생할지도 모르는 코드 블록을 정의하는 역할을 한다. try 블록 다음에는 catch절이 이어진다. catch절은 try 블록 내부에서 예외가 발생할 경우 호출되는 구문 블록이다. catch절 다음에는 finally 블록이 올 수 있는데, 여기에서는 try 블록에서 일어난 일에 관계없이 항상 실행이 보장되어야 할 뒷정리용 코드가 포함된다. catch나 finally 블록은 생략할 수 있다.  
하지만 try 블록은 적어도 이들 중 하나 이상의 블록과 함께 사용되어야 한다.
2. 형식
    ```
        try {
            //보통 이 코드는 아무런 문제없이 블록의 시작부터 끝까지 실행된다.
            // 하지만 경우에 따라 예외가 발생할 수 있다.
            //예외는 throw문에 의해 직접적으로 발생할 수도 있고,
            //또는 예외를 발생시키는 메서드의 호출에 의해 발생할 수도 있다.
        }
        catch(e) {
            //이 블록 내부의 구문들은 오직 try 블록에서 예외가 발생한 경우에 실행된다.
            //이 구문들에서는 지역 변수 e를 사용해 Error객체 또는
            //앞에서 던진 다른 값을 참조할 수 있다.
            //이 블록에서는 어떻게든 그 예외를 처리할 수도 있고,
            //그냥 아무것도 하지 않고 예외를 무시할 수도 있고,
            //아니면 throw를 사용해서 예외를 다시 발생시킬 수도 있다.
        }
        finally {
            //이 블록에는 try 블록에서 일어난 일에 관계없이 무조건 실행될 코드가 위치한다.
            //이 코드는 try 블록이 어떻게든 종료되면 실행된다.
            //try 브록이 종료되는 상황은 다음과 같다.
            // 1) 정상적으로 블록의 끝에 도달했을 때
            // 2) break, continue 또는 return문에 의해서
            // 3) 예외가 발생했지만 앞의 catch절에서 처리되었을 때
            // 4) 예외가 발생했고 그것이 잡히지 않은 채 퍼져나갈 때
        }
    ```
3. finally 블록 자체에서 return, continue, break 또는 throw문을 사용하거나 예외를 발생시키는 메서드를 호출해서 제어 흐름을 이동시킬 수 있다. 이때, 인터프리터는 기존에 finally 블록 이후의 코드를 실행하지 않는 대신 블록 내에서 가리키는 새로운 위치에서부터 코드를 실행한다.
    - 예를 들어, finally 절에서 예외를 발생시키면 그 예외가 기존에 발생해서 처리 중이던 예외를 대신한다.
    - 만약 finally절에서 return문을 실행했다면, 기존에 발생한 예외가 아직처리되지 않았다 하더라도 이 메서드는 정상적으로 반환된다.
    - while 루프를 for 루프로 흉내 낼 수 있다.
        ```
            //for 루프 흉내내기
            while(테스트) {
                try {
                    몸체;
                }
                finally {
                    증가;
                }
            }
        ```

# 기타 구문
### with
1. with문은 유효범위 체인을 임시로 변경하려 할 때 쓰인다.
2. 문법
    ```
        with(객체)
            구문
    ```
3. ```
    //만약 form에 여러 번 접금해야 할 경우에 with문을 사용해서 유효범위 체인에 form 객체를 추가 할 수 있다.
    with(document.forms[0]) { 
        //여기서 form 엘리먼트에 직접 접근할 수 있다. 
        name.value = '';
        address.value = '';
        email.value = '';
    }
    //with에 의해 추가된 임시 객체는 일시적으로 유효범위 체인의 일부가 되고, 자바스크립트가 address와 같은 식별자를 판별하려고 할 때 사용된다.
    ```
4. 만약 객체가 프로퍼티를 갖고 있다면 프러퍼티에 값을 할당하지만 객체에 프로퍼티가 없다면 with문과 상관없이 x=1을 실행한다.
    ```
    //유효범위 체인은 식별자를 생성할 때 사용하지 않고 판별할 때 사용한다.
        with(o) x = 1;
    ```

### debugger
1. debugger문은 코드의 중단점과 같이 동작한다.

### use strict
1. 스크립트의 시작 부분이나 함수 몸체의 시작 부분에만 올 수 있다. 하지만 반드시 스크립트나 함수의 시작 부분이 될 필요는 없다.
2. "use strict" 지시어를 사용하는 목적은 지시어 다음에 오는 코드들이 엄격한 모드를 따르게 하기 위해서다.
    - with 문은 엄격한 모드에서는 사용할 수 없다.